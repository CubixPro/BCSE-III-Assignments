"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _createEmotion = _interopRequireDefault(require("create-emotion"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _createCSSKey = _interopRequireDefault(require("../createCSSKey"));

var _debug = _interopRequireDefault(require("../utils/debug"));

var _EventSpy = _interopRequireDefault(require("../EventSpy"));

var _FunctionContext = _interopRequireDefault(require("./FunctionContext"));

var _InternalContext = _interopRequireDefault(require("./InternalContext"));

var _SpineTo = _interopRequireDefault(require("../SpineTo"));

var _State1Context = _interopRequireDefault(require("./State1Context"));

var _State2Context = _interopRequireDefault(require("./State2Context"));

var _StateContext = _interopRequireDefault(require("./StateContext"));

var _styleConsole = _interopRequireDefault(require("../utils/styleConsole"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var DEFAULT_SCROLLER = function DEFAULT_SCROLLER() {
  return Infinity;
};

var MIN_CHECK_INTERVAL = 17; // 1 frame

var MODE_BOTTOM = 'bottom';
var MODE_TOP = 'top';
var NEAR_END_THRESHOLD = 1;
var SCROLL_DECISION_DURATION = 34; // 2 frames
// We pool the emotion object by nonce.
// This is to make sure we don't generate too many unneeded <style> tags.

var emotionPool = {};

function setImmediateInterval(fn, ms) {
  fn();
  return setInterval(fn, ms);
}

function computeViewState(_ref) {
  var mode = _ref.mode,
      _ref$target = _ref.target,
      offsetHeight = _ref$target.offsetHeight,
      scrollHeight = _ref$target.scrollHeight,
      scrollTop = _ref$target.scrollTop;
  var atBottom = scrollHeight - scrollTop - offsetHeight < NEAR_END_THRESHOLD;
  var atTop = scrollTop < NEAR_END_THRESHOLD;
  var atEnd = mode === MODE_TOP ? atTop : atBottom;
  var atStart = mode !== MODE_TOP ? atTop : atBottom;
  return {
    atBottom: atBottom,
    atEnd: atEnd,
    atStart: atStart,
    atTop: atTop
  };
}

function isEnd(animateTo, mode) {
  return animateTo === (mode === MODE_TOP ? 0 : '100%');
}

var Composer = function Composer(_ref2) {
  var checkInterval = _ref2.checkInterval,
      children = _ref2.children,
      debounce = _ref2.debounce,
      forceDebug = _ref2.debug,
      initialScrollBehavior = _ref2.initialScrollBehavior,
      mode = _ref2.mode,
      nonce = _ref2.nonce,
      scroller = _ref2.scroller;
  var debug = (0, _react.useMemo)(function () {
    return (0, _debug.default)("<ScrollToBottom>", {
      force: forceDebug
    });
  }, [forceDebug]);
  mode = mode === MODE_TOP ? MODE_TOP : MODE_BOTTOM;
  var ignoreScrollEventBeforeRef = (0, _react.useRef)(0);
  var initialScrollBehaviorRef = (0, _react.useRef)(initialScrollBehavior);

  var _useState = (0, _react.useState)(mode === MODE_TOP ? 0 : '100%'),
      _useState2 = _slicedToArray(_useState, 2),
      animateTo = _useState2[0],
      setAnimateTo = _useState2[1];

  var _useState3 = (0, _react.useState)(null),
      _useState4 = _slicedToArray(_useState3, 2),
      target = _useState4[0],
      setTarget = _useState4[1]; // Internal context


  var animateFromRef = (0, _react.useRef)(0);
  var offsetHeightRef = (0, _react.useRef)(0);
  var scrollHeightRef = (0, _react.useRef)(0); // State context

  var animating = animateTo !== null;

  var _useState5 = (0, _react.useState)(true),
      _useState6 = _slicedToArray(_useState5, 2),
      atBottom = _useState6[0],
      setAtBottom = _useState6[1];

  var _useState7 = (0, _react.useState)(true),
      _useState8 = _slicedToArray(_useState7, 2),
      atEnd = _useState8[0],
      setAtEnd = _useState8[1];

  var _useState9 = (0, _react.useState)(true),
      _useState10 = _slicedToArray(_useState9, 2),
      atTop = _useState10[0],
      setAtTop = _useState10[1];

  var _useState11 = (0, _react.useState)(false),
      _useState12 = _slicedToArray(_useState11, 2),
      atStart = _useState12[0],
      setAtStart = _useState12[1];

  var _useState13 = (0, _react.useState)(true),
      _useState14 = _slicedToArray(_useState13, 2),
      sticky = _useState14[0],
      setSticky = _useState14[1]; // High-rate state context


  var scrollPositionObserversRef = (0, _react.useRef)([]);
  var observeScrollPosition = (0, _react.useCallback)(function (fn) {
    scrollPositionObserversRef.current.push(fn);
    target && fn({
      scrollTop: target.scrollTop
    });
    return function () {
      var scrollPositionObservers = scrollPositionObserversRef.current;
      var index = scrollPositionObservers.indexOf(fn);
      ~index && scrollPositionObservers.splice(index, 1);
    };
  }, [scrollPositionObserversRef, target]);
  var handleSpineToEnd = (0, _react.useCallback)(function () {
    debug(function () {
      return ['%cSpineTo%c: %conEnd%c is fired.'].concat(_toConsumableArray((0, _styleConsole.default)('magenta')), _toConsumableArray((0, _styleConsole.default)('orange')), [{
        animateTo: animateTo
      }]);
    });
    ignoreScrollEventBeforeRef.current = Date.now(); // handleScrollEnd may end at a position which should lose stickiness.
    // In that case, we will need to set sticky to false to stop the interval check.
    // Test case:
    // 1. Add a scroller that always return 0
    // 2. Show a panel with mode === MODE_BOTTOM
    // 3. Programmatically scroll to 0 (set element.scrollTop = 0)
    // Expected: it should not repetitively call scrollTo(0)
    //           it should set stickiness to false

    isEnd(animateTo, mode) || setSticky(false);
    setAnimateTo(null);
  }, [animateTo, debug, ignoreScrollEventBeforeRef, mode, setAnimateTo, setSticky]); // Function context

  var scrollTo = (0, _react.useCallback)(function (nextAnimateTo) {
    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        behavior = _ref3.behavior;

    if (typeof nextAnimateTo !== 'number' && nextAnimateTo !== '100%') {
      return console.warn('react-scroll-to-bottom: Arguments passed to scrollTo() must be either number or "100%".');
    } // If it is trying to scroll to a position which is not "atEnd", it should set sticky to false after scroll ended.


    debug(function () {
      return [["%cscrollTo%c: Will scroll to %c".concat(typeof nextAnimateTo === 'number' ? nextAnimateTo + 'px' : nextAnimateTo.replace(/%/g, '%%'), "%c")].concat(_toConsumableArray((0, _styleConsole.default)('lime', '')), _toConsumableArray((0, _styleConsole.default)('purple'))), {
        behavior: behavior,
        nextAnimateTo: nextAnimateTo,
        target: target
      }];
    });

    if (behavior === 'auto') {
      // Stop any existing animation
      handleSpineToEnd();

      if (target) {
        // Jump to the scroll position
        target.scrollTop = nextAnimateTo === '100%' ? target.scrollHeight - target.offsetHeight : nextAnimateTo;
      }
    } else {
      behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollTo". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
      setAnimateTo(nextAnimateTo);
    } // This is for handling a case. When calling scrollTo('100%', { behavior: 'auto' }) multiple times, it would lose stickiness.


    isEnd(nextAnimateTo, mode) && setSticky(true);
  }, [debug, handleSpineToEnd, mode, setAnimateTo, setSticky, target]);
  var scrollToBottom = (0, _react.useCallback)(function () {
    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        behavior = _ref4.behavior;

    debug(function () {
      return ['%cscrollToBottom%c: Called'].concat(_toConsumableArray((0, _styleConsole.default)('yellow', '')));
    });
    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToBottom". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    scrollTo('100%', {
      behavior: behavior || 'smooth'
    });
  }, [debug, scrollTo]);
  var scrollToTop = (0, _react.useCallback)(function () {
    var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        behavior = _ref5.behavior;

    debug(function () {
      return ['%cscrollToTop%c: Called'].concat(_toConsumableArray((0, _styleConsole.default)('yellow', '')));
    });
    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToTop". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    scrollTo(0, {
      behavior: behavior || 'smooth'
    });
  }, [debug, scrollTo]);
  var scrollToEnd = (0, _react.useCallback)(function () {
    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        behavior = _ref6.behavior;

    debug(function () {
      return ['%cscrollToEnd%c: Called'].concat(_toConsumableArray((0, _styleConsole.default)('yellow', '')));
    });
    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToEnd". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    var options = {
      behavior: behavior || 'smooth'
    };
    mode === MODE_TOP ? scrollToTop(options) : scrollToBottom(options);
  }, [debug, mode, scrollToBottom, scrollToTop]);
  var scrollToStart = (0, _react.useCallback)(function () {
    var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        behavior = _ref7.behavior;

    debug(function () {
      return ['%cscrollToStart%c: Called'].concat(_toConsumableArray((0, _styleConsole.default)('yellow', '')));
    });
    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToStart". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    var options = {
      behavior: behavior || 'smooth'
    };
    mode === MODE_TOP ? scrollToBottom(options) : scrollToTop(options);
  }, [debug, mode, scrollToBottom, scrollToTop]);
  var scrollToSticky = (0, _react.useCallback)(function () {
    if (target) {
      if (initialScrollBehaviorRef.current === 'auto') {
        debug(function () {
          return ["%ctarget changed%c: Initial scroll"].concat(_toConsumableArray((0, _styleConsole.default)('blue')));
        });
        target.scrollTop = mode === MODE_TOP ? 0 : target.scrollHeight - target.offsetHeight;
        initialScrollBehaviorRef.current = false;
        return;
      } // This is very similar to scrollToEnd().
      // Instead of scrolling to end, it will call props.scroller() to determines how far it should scroll.
      // This function could be called while it is auto-scrolling.


      var animateFrom = animateFromRef.current;
      var offsetHeight = target.offsetHeight,
          scrollHeight = target.scrollHeight,
          scrollTop = target.scrollTop;
      var maxValue = mode === MODE_TOP ? 0 : Math.max(0, scrollHeight - offsetHeight - scrollTop);
      var minValue = Math.max(0, animateFrom - scrollTop);
      var rawNextValue = scroller({
        maxValue: maxValue,
        minValue: minValue,
        offsetHeight: offsetHeight,
        scrollHeight: scrollHeight,
        scrollTop: scrollTop
      });
      var nextValue = Math.max(0, Math.min(maxValue, rawNextValue));
      var nextAnimateTo;

      if (mode === MODE_TOP || nextValue !== maxValue) {
        nextAnimateTo = scrollTop + nextValue;
      } else {
        // When scrolling to bottom, we should scroll to "100%".
        // Otherwise, if we scroll to any number, it will lose stickiness when elements are adding too fast.
        // "100%" is a special argument intended to make sure stickiness is not lost while new elements are being added.
        nextAnimateTo = '100%';
      }

      debug(function () {
        return [["%cscrollToSticky%c: Will animate from %c".concat(animateFrom, "px%c to %c").concat(typeof nextAnimateTo === 'number' ? nextAnimateTo + 'px' : nextAnimateTo.replace(/%/g, '%%'), "%c (%c").concat((nextAnimateTo === '100%' ? maxValue : nextAnimateTo) + animateFrom, "px%c)")].concat(_toConsumableArray((0, _styleConsole.default)('orange')), _toConsumableArray((0, _styleConsole.default)('purple')), _toConsumableArray((0, _styleConsole.default)('purple')), _toConsumableArray((0, _styleConsole.default)('purple'))), {
          animateFrom: animateFrom,
          maxValue: maxValue,
          minValue: minValue,
          nextAnimateTo: nextAnimateTo,
          nextValue: nextValue,
          offsetHeight: offsetHeight,
          rawNextValue: rawNextValue,
          scrollHeight: scrollHeight,
          scrollTop: scrollTop
        }];
      });
      scrollTo(nextAnimateTo, {
        behavior: 'smooth'
      });
    }
  }, [animateFromRef, debug, mode, scroller, scrollTo, target]);
  var handleScroll = (0, _react.useCallback)(function (_ref8) {
    var timeStampLow = _ref8.timeStampLow;

    // Currently, there are no reliable way to check if the "scroll" event is trigger due to
    // user gesture, programmatic scrolling, or Chrome-synthesized "scroll" event to compensate size change.
    // Thus, we use our best-effort to guess if it is triggered by user gesture, and disable sticky if it is heading towards the start direction.
    if (timeStampLow <= ignoreScrollEventBeforeRef.current || !target) {
      // Since we debounce "scroll" event, this handler might be called after spineTo.onEnd (a.k.a. artificial scrolling).
      // We should ignore debounced event fired after scrollEnd, because without skipping them, the userInitiatedScroll calculated below will not be accurate.
      // Thus, on a fast machine, adding elements super fast will lose the "stickiness".
      return;
    }

    var _computeViewState = computeViewState({
      mode: mode,
      target: target
    }),
        atBottom = _computeViewState.atBottom,
        atEnd = _computeViewState.atEnd,
        atStart = _computeViewState.atStart,
        atTop = _computeViewState.atTop;

    setAtBottom(atBottom);
    setAtEnd(atEnd);
    setAtStart(atStart);
    setAtTop(atTop); // Chrome will emit "synthetic" scroll event if the container is resized or an element is added
    // We need to ignore these "synthetic" events
    // Repro: In playground, press 4-1-5-1-1 (small, add one, normal, add one, add one)
    //        Nomatter how fast or slow the sequence is being pressed, it should still stick to the bottom

    var nextOffsetHeight = target.offsetHeight,
        nextScrollHeight = target.scrollHeight;
    var offsetHeight = offsetHeightRef.current;
    var scrollHeight = scrollHeightRef.current;
    var offsetHeightChanged = nextOffsetHeight !== offsetHeight;
    var scrollHeightChanged = nextScrollHeight !== scrollHeight;

    if (offsetHeightChanged) {
      offsetHeightRef.current = nextOffsetHeight;
    }

    if (scrollHeightChanged) {
      scrollHeightRef.current = nextScrollHeight;
    } // Sticky means:
    // - If it is scrolled programatically, we are still in sticky mode
    // - If it is scrolled by the user, then sticky means if we are at the end
    // Only update stickiness if the scroll event is not due to synthetic scroll done by Chrome


    if (!offsetHeightChanged && !scrollHeightChanged) {
      // We are sticky if we are animating to the end, or we are already at the end.
      // We can be "animating but not sticky" by calling "scrollTo(100)" where the container scrollHeight is 200px.
      var nextSticky = animating && isEnd(animateTo, mode) || atEnd;

      if (sticky !== nextSticky) {
        debug(function () {
          return [["%conScroll%c: %csetSticky%c(%c".concat(nextSticky, "%c)")].concat(_toConsumableArray((0, _styleConsole.default)('red')), _toConsumableArray((0, _styleConsole.default)('red')), _toConsumableArray((0, _styleConsole.default)('purple'))), ["(animating = %c".concat(animating, "%c && isEnd = %c").concat(isEnd(animateTo, mode), "%c) || atEnd = %c").concat(atEnd, "%c")].concat(_toConsumableArray((0, _styleConsole.default)('purple')), _toConsumableArray((0, _styleConsole.default)('purple')), _toConsumableArray((0, _styleConsole.default)('purple')), [{
            animating: animating,
            animateTo: animateTo,
            atEnd: atEnd,
            mode: mode,
            offsetHeight: target.offsetHeight,
            scrollHeight: target.scrollHeight,
            sticky: sticky,
            nextSticky: nextSticky
          }])];
        });
        setSticky(nextSticky);
      }
    } else if (sticky) {
      debug(function () {
        return [["%conScroll%c: Size changed while sticky, calling %cscrollToSticky()%c"].concat(_toConsumableArray((0, _styleConsole.default)('red')), _toConsumableArray((0, _styleConsole.default)('orange')), [{
          offsetHeightChanged: offsetHeightChanged,
          scrollHeightChanged: scrollHeightChanged
        }]), {
          nextOffsetHeight: nextOffsetHeight,
          prevOffsetHeight: offsetHeight,
          nextScrollHeight: nextScrollHeight,
          prevScrollHeight: scrollHeight
        }];
      });
      scrollToSticky();
    }

    var actualScrollTop = target.scrollTop;
    scrollPositionObserversRef.current.forEach(function (observer) {
      return observer({
        scrollTop: actualScrollTop
      });
    });
  }, [animateTo, animating, debug, ignoreScrollEventBeforeRef, mode, offsetHeightRef, scrollHeightRef, scrollPositionObserversRef, scrollToSticky, setAtBottom, setAtEnd, setAtStart, setAtTop, setSticky, sticky, target]);
  (0, _react.useEffect)(function () {
    if (target) {
      var stickyButNotAtEndSince = false;
      var timeout = setImmediateInterval(function () {
        if (sticky) {
          if (!computeViewState({
            mode: mode,
            target: target
          }).atEnd) {
            if (!stickyButNotAtEndSince) {
              stickyButNotAtEndSince = Date.now();
            } else if (Date.now() - stickyButNotAtEndSince > SCROLL_DECISION_DURATION) {
              // Quirks: In Firefox, after user scroll down, Firefox do two things:
              //         1. Set to a new "scrollTop"
              //         2. Fire "scroll" event
              //         For what we observed, #1 is fired about 20ms before #2. There is a chance that this stickyCheckTimeout is being scheduled between 1 and 2.
              //         That means, if we just look at #1 to decide if we should scroll, we will always scroll, in oppose to the user's intention.
              // Repro: Open Firefox, set checkInterval to a lower number, and try to scroll by dragging the scroll handler. It will jump back.
              // The "animating" check will make sure stickiness is not lost when elements are adding at a very fast pace.
              if (!animating) {
                animateFromRef.current = target.scrollTop;
                debug(function () {
                  return ["%cInterval check%c: Should sticky but not at end, calling %cscrollToSticky()%c to scroll"].concat(_toConsumableArray((0, _styleConsole.default)('navy')), _toConsumableArray((0, _styleConsole.default)('orange')));
                });
                scrollToSticky();
              }

              stickyButNotAtEndSince = false;
            }
          } else {
            stickyButNotAtEndSince = false;
          }
        } else if (target.scrollHeight <= target.offsetHeight && !sticky) {
          // When the container is emptied, we will set sticky back to true.
          setSticky(true);
        }
      }, Math.max(MIN_CHECK_INTERVAL, checkInterval) || MIN_CHECK_INTERVAL);
      return function () {
        return clearInterval(timeout);
      };
    }
  }, [animating, checkInterval, debug, mode, scrollToSticky, setSticky, sticky, target]);
  var styleToClassName = (0, _react.useMemo)(function () {
    var emotion = emotionPool[nonce] || (emotionPool[nonce] = (0, _createEmotion.default)({
      key: 'react-scroll-to-bottom--css-' + (0, _createCSSKey.default)(),
      nonce: nonce
    }));
    return function (style) {
      return emotion.css(style) + '';
    };
  }, [nonce]);
  var internalContext = (0, _react.useMemo)(function () {
    return {
      observeScrollPosition: observeScrollPosition,
      setTarget: setTarget,
      styleToClassName: styleToClassName
    };
  }, [observeScrollPosition, setTarget, styleToClassName]);
  var state1Context = (0, _react.useMemo)(function () {
    return {
      atBottom: atBottom,
      atEnd: atEnd,
      atStart: atStart,
      atTop: atTop,
      mode: mode
    };
  }, [atBottom, atEnd, atStart, atTop, mode]);
  var state2Context = (0, _react.useMemo)(function () {
    return {
      animating: animating,
      animatingToEnd: animating && isEnd(animateTo, mode),
      sticky: sticky
    };
  }, [animating, animateTo, debug, mode, sticky]);
  var combinedStateContext = (0, _react.useMemo)(function () {
    return _objectSpread(_objectSpread({}, state1Context), state2Context);
  }, [state1Context, state2Context]);
  var functionContext = (0, _react.useMemo)(function () {
    return {
      scrollTo: scrollTo,
      scrollToBottom: scrollToBottom,
      scrollToEnd: scrollToEnd,
      scrollToStart: scrollToStart,
      scrollToTop: scrollToTop
    };
  }, [scrollTo, scrollToBottom, scrollToEnd, scrollToStart, scrollToTop]);
  (0, _react.useEffect)(function () {
    // We need to update the "scrollHeight" value to latest when the user do a focus inside the box.
    //
    // This is because:
    // - In our code that mitigate Chrome synthetic scrolling, that code will look at whether "scrollHeight" value is latest or not.
    // - That code only run on "scroll" event.
    // - That means, on every "scroll" event, if the "scrollHeight" value is not latest, we will skip modifying the stickiness.
    // - That means, if the user "focus" to an element that cause the scroll view to scroll to the bottom, the user agent will fire "scroll" event.
    //   Since the "scrollHeight" is not latest value, this "scroll" event will be ignored and stickiness will not be modified.
    // - That means, if the user "focus" to a newly added element that is at the end of the scroll view, the "scroll to bottom" button will continue to show.
    //
    // Repro in Chrome:
    // 1. Fill up a scroll view
    // 2. Scroll up, the "scroll to bottom" button should show up
    // 3. Click "Add a button"
    // 4. Click on the scroll view (to pseudo-focus on it)
    // 5. Press TAB, the scroll view will be at the bottom
    //
    // Expect:
    // - The "scroll to bottom" button should be gone.
    if (target) {
      var handleFocus = function handleFocus() {
        scrollHeightRef.current = target.scrollHeight;
      };

      target.addEventListener('focus', handleFocus, {
        capture: true,
        passive: true
      });
      return function () {
        return target.removeEventListener('focus', handleFocus);
      };
    }
  }, [target]);
  debug(function () {
    return [["%cRender%c: Render"].concat(_toConsumableArray((0, _styleConsole.default)('cyan', ''))), {
      animateTo: animateTo,
      animating: animating,
      sticky: sticky,
      target: target
    }];
  });
  return /*#__PURE__*/_react.default.createElement(_InternalContext.default.Provider, {
    value: internalContext
  }, /*#__PURE__*/_react.default.createElement(_FunctionContext.default.Provider, {
    value: functionContext
  }, /*#__PURE__*/_react.default.createElement(_StateContext.default.Provider, {
    value: combinedStateContext
  }, /*#__PURE__*/_react.default.createElement(_State1Context.default.Provider, {
    value: state1Context
  }, /*#__PURE__*/_react.default.createElement(_State2Context.default.Provider, {
    value: state2Context
  }, children, target && /*#__PURE__*/_react.default.createElement(_EventSpy.default, {
    debounce: debounce,
    name: "scroll",
    onEvent: handleScroll,
    target: target
  }), target && animateTo !== null && /*#__PURE__*/_react.default.createElement(_SpineTo.default, {
    name: "scrollTop",
    onEnd: handleSpineToEnd,
    target: target,
    value: animateTo
  }))))));
};

Composer.defaultProps = {
  checkInterval: 100,
  children: undefined,
  debounce: 17,
  debug: false,
  initialScrollBehavior: 'smooth',
  mode: undefined,
  nonce: undefined,
  scroller: DEFAULT_SCROLLER
};
Composer.propTypes = {
  checkInterval: _propTypes.default.number,
  children: _propTypes.default.any,
  debounce: _propTypes.default.number,
  debug: _propTypes.default.bool,
  initialScrollBehavior: _propTypes.default.oneOf(['auto', 'smooth']),
  mode: _propTypes.default.oneOf(['bottom', 'top']),
  nonce: _propTypes.default.string,
  scroller: _propTypes.default.func
};
var _default = Composer;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9TY3JvbGxUb0JvdHRvbS9Db21wb3Nlci5qcyJdLCJuYW1lcyI6WyJERUZBVUxUX1NDUk9MTEVSIiwiSW5maW5pdHkiLCJNSU5fQ0hFQ0tfSU5URVJWQUwiLCJNT0RFX0JPVFRPTSIsIk1PREVfVE9QIiwiTkVBUl9FTkRfVEhSRVNIT0xEIiwiU0NST0xMX0RFQ0lTSU9OX0RVUkFUSU9OIiwiZW1vdGlvblBvb2wiLCJzZXRJbW1lZGlhdGVJbnRlcnZhbCIsImZuIiwibXMiLCJzZXRJbnRlcnZhbCIsImNvbXB1dGVWaWV3U3RhdGUiLCJtb2RlIiwidGFyZ2V0Iiwib2Zmc2V0SGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0Iiwic2Nyb2xsVG9wIiwiYXRCb3R0b20iLCJhdFRvcCIsImF0RW5kIiwiYXRTdGFydCIsImlzRW5kIiwiYW5pbWF0ZVRvIiwiQ29tcG9zZXIiLCJjaGVja0ludGVydmFsIiwiY2hpbGRyZW4iLCJkZWJvdW5jZSIsImZvcmNlRGVidWciLCJkZWJ1ZyIsImluaXRpYWxTY3JvbGxCZWhhdmlvciIsIm5vbmNlIiwic2Nyb2xsZXIiLCJmb3JjZSIsImlnbm9yZVNjcm9sbEV2ZW50QmVmb3JlUmVmIiwiaW5pdGlhbFNjcm9sbEJlaGF2aW9yUmVmIiwic2V0QW5pbWF0ZVRvIiwic2V0VGFyZ2V0IiwiYW5pbWF0ZUZyb21SZWYiLCJvZmZzZXRIZWlnaHRSZWYiLCJzY3JvbGxIZWlnaHRSZWYiLCJhbmltYXRpbmciLCJzZXRBdEJvdHRvbSIsInNldEF0RW5kIiwic2V0QXRUb3AiLCJzZXRBdFN0YXJ0Iiwic3RpY2t5Iiwic2V0U3RpY2t5Iiwic2Nyb2xsUG9zaXRpb25PYnNlcnZlcnNSZWYiLCJvYnNlcnZlU2Nyb2xsUG9zaXRpb24iLCJjdXJyZW50IiwicHVzaCIsInNjcm9sbFBvc2l0aW9uT2JzZXJ2ZXJzIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwiaGFuZGxlU3BpbmVUb0VuZCIsIkRhdGUiLCJub3ciLCJzY3JvbGxUbyIsIm5leHRBbmltYXRlVG8iLCJiZWhhdmlvciIsImNvbnNvbGUiLCJ3YXJuIiwicmVwbGFjZSIsInNjcm9sbFRvQm90dG9tIiwic2Nyb2xsVG9Ub3AiLCJzY3JvbGxUb0VuZCIsIm9wdGlvbnMiLCJzY3JvbGxUb1N0YXJ0Iiwic2Nyb2xsVG9TdGlja3kiLCJhbmltYXRlRnJvbSIsIm1heFZhbHVlIiwiTWF0aCIsIm1heCIsIm1pblZhbHVlIiwicmF3TmV4dFZhbHVlIiwibmV4dFZhbHVlIiwibWluIiwiaGFuZGxlU2Nyb2xsIiwidGltZVN0YW1wTG93IiwibmV4dE9mZnNldEhlaWdodCIsIm5leHRTY3JvbGxIZWlnaHQiLCJvZmZzZXRIZWlnaHRDaGFuZ2VkIiwic2Nyb2xsSGVpZ2h0Q2hhbmdlZCIsIm5leHRTdGlja3kiLCJwcmV2T2Zmc2V0SGVpZ2h0IiwicHJldlNjcm9sbEhlaWdodCIsImFjdHVhbFNjcm9sbFRvcCIsImZvckVhY2giLCJvYnNlcnZlciIsInN0aWNreUJ1dE5vdEF0RW5kU2luY2UiLCJ0aW1lb3V0IiwiY2xlYXJJbnRlcnZhbCIsInN0eWxlVG9DbGFzc05hbWUiLCJlbW90aW9uIiwia2V5Iiwic3R5bGUiLCJjc3MiLCJpbnRlcm5hbENvbnRleHQiLCJzdGF0ZTFDb250ZXh0Iiwic3RhdGUyQ29udGV4dCIsImFuaW1hdGluZ1RvRW5kIiwiY29tYmluZWRTdGF0ZUNvbnRleHQiLCJmdW5jdGlvbkNvbnRleHQiLCJoYW5kbGVGb2N1cyIsImFkZEV2ZW50TGlzdGVuZXIiLCJjYXB0dXJlIiwicGFzc2l2ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZWZhdWx0UHJvcHMiLCJ1bmRlZmluZWQiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJudW1iZXIiLCJhbnkiLCJib29sIiwib25lT2YiLCJzdHJpbmciLCJmdW5jIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFD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ICdjcmVhdGUtZW1vdGlvbic7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBjcmVhdGVDU1NLZXkgZnJvbSAnLi4vY3JlYXRlQ1NTS2V5JztcbmltcG9ydCBjcmVhdGVEZWJ1ZyBmcm9tICcuLi91dGlscy9kZWJ1Zyc7XG5pbXBvcnQgRXZlbnRTcHkgZnJvbSAnLi4vRXZlbnRTcHknO1xuaW1wb3J0IEZ1bmN0aW9uQ29udGV4dCBmcm9tICcuL0Z1bmN0aW9uQ29udGV4dCc7XG5pbXBvcnQgSW50ZXJuYWxDb250ZXh0IGZyb20gJy4vSW50ZXJuYWxDb250ZXh0JztcbmltcG9ydCBTcGluZVRvIGZyb20gJy4uL1NwaW5lVG8nO1xuaW1wb3J0IFN0YXRlMUNvbnRleHQgZnJvbSAnLi9TdGF0ZTFDb250ZXh0JztcbmltcG9ydCBTdGF0ZTJDb250ZXh0IGZyb20gJy4vU3RhdGUyQ29udGV4dCc7XG5pbXBvcnQgU3RhdGVDb250ZXh0IGZyb20gJy4vU3RhdGVDb250ZXh0JztcbmltcG9ydCBzdHlsZUNvbnNvbGUgZnJvbSAnLi4vdXRpbHMvc3R5bGVDb25zb2xlJztcblxuY29uc3QgREVGQVVMVF9TQ1JPTExFUiA9ICgpID0+IEluZmluaXR5O1xuY29uc3QgTUlOX0NIRUNLX0lOVEVSVkFMID0gMTc7IC8vIDEgZnJhbWVcbmNvbnN0IE1PREVfQk9UVE9NID0gJ2JvdHRvbSc7XG5jb25zdCBNT0RFX1RPUCA9ICd0b3AnO1xuY29uc3QgTkVBUl9FTkRfVEhSRVNIT0xEID0gMTtcbmNvbnN0IFNDUk9MTF9ERUNJU0lPTl9EVVJBVElPTiA9IDM0OyAvLyAyIGZyYW1lc1xuXG4vLyBXZSBwb29sIHRoZSBlbW90aW9uIG9iamVjdCBieSBub25jZS5cbi8vIFRoaXMgaXMgdG8gbWFrZSBzdXJlIHdlIGRvbid0IGdlbmVyYXRlIHRvbyBtYW55IHVubmVlZGVkIDxzdHlsZT4gdGFncy5cbmNvbnN0IGVtb3Rpb25Qb29sID0ge307XG5cbmZ1bmN0aW9uIHNldEltbWVkaWF0ZUludGVydmFsKGZuLCBtcykge1xuICBmbigpO1xuXG4gIHJldHVybiBzZXRJbnRlcnZhbChmbiwgbXMpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlVmlld1N0YXRlKHsgbW9kZSwgdGFyZ2V0OiB7IG9mZnNldEhlaWdodCwgc2Nyb2xsSGVpZ2h0LCBzY3JvbGxUb3AgfSB9KSB7XG4gIGNvbnN0IGF0Qm90dG9tID0gc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsVG9wIC0gb2Zmc2V0SGVpZ2h0IDwgTkVBUl9FTkRfVEhSRVNIT0xEO1xuICBjb25zdCBhdFRvcCA9IHNjcm9sbFRvcCA8IE5FQVJfRU5EX1RIUkVTSE9MRDtcblxuICBjb25zdCBhdEVuZCA9IG1vZGUgPT09IE1PREVfVE9QID8gYXRUb3AgOiBhdEJvdHRvbTtcbiAgY29uc3QgYXRTdGFydCA9IG1vZGUgIT09IE1PREVfVE9QID8gYXRUb3AgOiBhdEJvdHRvbTtcblxuICByZXR1cm4ge1xuICAgIGF0Qm90dG9tLFxuICAgIGF0RW5kLFxuICAgIGF0U3RhcnQsXG4gICAgYXRUb3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNFbmQoYW5pbWF0ZVRvLCBtb2RlKSB7XG4gIHJldHVybiBhbmltYXRlVG8gPT09IChtb2RlID09PSBNT0RFX1RPUCA/IDAgOiAnMTAwJScpO1xufVxuXG5jb25zdCBDb21wb3NlciA9ICh7XG4gIGNoZWNrSW50ZXJ2YWwsXG4gIGNoaWxkcmVuLFxuICBkZWJvdW5jZSxcbiAgZGVidWc6IGZvcmNlRGVidWcsXG4gIGluaXRpYWxTY3JvbGxCZWhhdmlvcixcbiAgbW9kZSxcbiAgbm9uY2UsXG4gIHNjcm9sbGVyXG59KSA9PiB7XG4gIGNvbnN0IGRlYnVnID0gdXNlTWVtbygoKSA9PiBjcmVhdGVEZWJ1ZyhgPFNjcm9sbFRvQm90dG9tPmAsIHsgZm9yY2U6IGZvcmNlRGVidWcgfSksIFtmb3JjZURlYnVnXSk7XG5cbiAgbW9kZSA9IG1vZGUgPT09IE1PREVfVE9QID8gTU9ERV9UT1AgOiBNT0RFX0JPVFRPTTtcblxuICBjb25zdCBpZ25vcmVTY3JvbGxFdmVudEJlZm9yZVJlZiA9IHVzZVJlZigwKTtcbiAgY29uc3QgaW5pdGlhbFNjcm9sbEJlaGF2aW9yUmVmID0gdXNlUmVmKGluaXRpYWxTY3JvbGxCZWhhdmlvcik7XG4gIGNvbnN0IFthbmltYXRlVG8sIHNldEFuaW1hdGVUb10gPSB1c2VTdGF0ZShtb2RlID09PSBNT0RFX1RPUCA/IDAgOiAnMTAwJScpO1xuICBjb25zdCBbdGFyZ2V0LCBzZXRUYXJnZXRdID0gdXNlU3RhdGUobnVsbCk7XG5cbiAgLy8gSW50ZXJuYWwgY29udGV4dFxuICBjb25zdCBhbmltYXRlRnJvbVJlZiA9IHVzZVJlZigwKTtcbiAgY29uc3Qgb2Zmc2V0SGVpZ2h0UmVmID0gdXNlUmVmKDApO1xuICBjb25zdCBzY3JvbGxIZWlnaHRSZWYgPSB1c2VSZWYoMCk7XG5cbiAgLy8gU3RhdGUgY29udGV4dFxuICBjb25zdCBhbmltYXRpbmcgPSBhbmltYXRlVG8gIT09IG51bGw7XG4gIGNvbnN0IFthdEJvdHRvbSwgc2V0QXRCb3R0b21dID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFthdEVuZCwgc2V0QXRFbmRdID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFthdFRvcCwgc2V0QXRUb3BdID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFthdFN0YXJ0LCBzZXRBdFN0YXJ0XSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3N0aWNreSwgc2V0U3RpY2t5XSA9IHVzZVN0YXRlKHRydWUpO1xuXG4gIC8vIEhpZ2gtcmF0ZSBzdGF0ZSBjb250ZXh0XG4gIGNvbnN0IHNjcm9sbFBvc2l0aW9uT2JzZXJ2ZXJzUmVmID0gdXNlUmVmKFtdKTtcbiAgY29uc3Qgb2JzZXJ2ZVNjcm9sbFBvc2l0aW9uID0gdXNlQ2FsbGJhY2soXG4gICAgZm4gPT4ge1xuICAgICAgc2Nyb2xsUG9zaXRpb25PYnNlcnZlcnNSZWYuY3VycmVudC5wdXNoKGZuKTtcbiAgICAgIHRhcmdldCAmJiBmbih7IHNjcm9sbFRvcDogdGFyZ2V0LnNjcm9sbFRvcCB9KTtcblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50OiBzY3JvbGxQb3NpdGlvbk9ic2VydmVycyB9ID0gc2Nyb2xsUG9zaXRpb25PYnNlcnZlcnNSZWY7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gc2Nyb2xsUG9zaXRpb25PYnNlcnZlcnMuaW5kZXhPZihmbik7XG5cbiAgICAgICAgfmluZGV4ICYmIHNjcm9sbFBvc2l0aW9uT2JzZXJ2ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgW3Njcm9sbFBvc2l0aW9uT2JzZXJ2ZXJzUmVmLCB0YXJnZXRdXG4gICk7XG5cbiAgY29uc3QgaGFuZGxlU3BpbmVUb0VuZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBkZWJ1ZygoKSA9PiBbXG4gICAgICAnJWNTcGluZVRvJWM6ICVjb25FbmQlYyBpcyBmaXJlZC4nLFxuICAgICAgLi4uc3R5bGVDb25zb2xlKCdtYWdlbnRhJyksXG4gICAgICAuLi5zdHlsZUNvbnNvbGUoJ29yYW5nZScpLFxuICAgICAgeyBhbmltYXRlVG8gfVxuICAgIF0pO1xuXG4gICAgaWdub3JlU2Nyb2xsRXZlbnRCZWZvcmVSZWYuY3VycmVudCA9IERhdGUubm93KCk7XG5cbiAgICAvLyBoYW5kbGVTY3JvbGxFbmQgbWF5IGVuZCBhdCBhIHBvc2l0aW9uIHdoaWNoIHNob3VsZCBsb3NlIHN0aWNraW5lc3MuXG4gICAgLy8gSW4gdGhhdCBjYXNlLCB3ZSB3aWxsIG5lZWQgdG8gc2V0IHN0aWNreSB0byBmYWxzZSB0byBzdG9wIHRoZSBpbnRlcnZhbCBjaGVjay5cbiAgICAvLyBUZXN0IGNhc2U6XG4gICAgLy8gMS4gQWRkIGEgc2Nyb2xsZXIgdGhhdCBhbHdheXMgcmV0dXJuIDBcbiAgICAvLyAyLiBTaG93IGEgcGFuZWwgd2l0aCBtb2RlID09PSBNT0RFX0JPVFRPTVxuICAgIC8vIDMuIFByb2dyYW1tYXRpY2FsbHkgc2Nyb2xsIHRvIDAgKHNldCBlbGVtZW50LnNjcm9sbFRvcCA9IDApXG4gICAgLy8gRXhwZWN0ZWQ6IGl0IHNob3VsZCBub3QgcmVwZXRpdGl2ZWx5IGNhbGwgc2Nyb2xsVG8oMClcbiAgICAvLyAgICAgICAgICAgaXQgc2hvdWxkIHNldCBzdGlja2luZXNzIHRvIGZhbHNlXG5cbiAgICBpc0VuZChhbmltYXRlVG8sIG1vZGUpIHx8IHNldFN0aWNreShmYWxzZSk7XG4gICAgc2V0QW5pbWF0ZVRvKG51bGwpO1xuICB9LCBbYW5pbWF0ZVRvLCBkZWJ1ZywgaWdub3JlU2Nyb2xsRXZlbnRCZWZvcmVSZWYsIG1vZGUsIHNldEFuaW1hdGVUbywgc2V0U3RpY2t5XSk7XG5cbiAgLy8gRnVuY3Rpb24gY29udGV4dFxuICBjb25zdCBzY3JvbGxUbyA9IHVzZUNhbGxiYWNrKFxuICAgIChuZXh0QW5pbWF0ZVRvLCB7IGJlaGF2aW9yIH0gPSB7fSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBuZXh0QW5pbWF0ZVRvICE9PSAnbnVtYmVyJyAmJiBuZXh0QW5pbWF0ZVRvICE9PSAnMTAwJScpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybigncmVhY3Qtc2Nyb2xsLXRvLWJvdHRvbTogQXJndW1lbnRzIHBhc3NlZCB0byBzY3JvbGxUbygpIG11c3QgYmUgZWl0aGVyIG51bWJlciBvciBcIjEwMCVcIi4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQgaXMgdHJ5aW5nIHRvIHNjcm9sbCB0byBhIHBvc2l0aW9uIHdoaWNoIGlzIG5vdCBcImF0RW5kXCIsIGl0IHNob3VsZCBzZXQgc3RpY2t5IHRvIGZhbHNlIGFmdGVyIHNjcm9sbCBlbmRlZC5cblxuICAgICAgZGVidWcoKCkgPT4gW1xuICAgICAgICBbXG4gICAgICAgICAgYCVjc2Nyb2xsVG8lYzogV2lsbCBzY3JvbGwgdG8gJWMke1xuICAgICAgICAgICAgdHlwZW9mIG5leHRBbmltYXRlVG8gPT09ICdudW1iZXInID8gbmV4dEFuaW1hdGVUbyArICdweCcgOiBuZXh0QW5pbWF0ZVRvLnJlcGxhY2UoLyUvZ3UsICclJScpXG4gICAgICAgICAgfSVjYCxcbiAgICAgICAgICAuLi5zdHlsZUNvbnNvbGUoJ2xpbWUnLCAnJyksXG4gICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdwdXJwbGUnKVxuICAgICAgICBdLFxuICAgICAgICB7XG4gICAgICAgICAgYmVoYXZpb3IsXG4gICAgICAgICAgbmV4dEFuaW1hdGVUbyxcbiAgICAgICAgICB0YXJnZXRcbiAgICAgICAgfVxuICAgICAgXSk7XG5cbiAgICAgIGlmIChiZWhhdmlvciA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIC8vIFN0b3AgYW55IGV4aXN0aW5nIGFuaW1hdGlvblxuICAgICAgICBoYW5kbGVTcGluZVRvRW5kKCk7XG5cbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgIC8vIEp1bXAgdG8gdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgICAgICAgIHRhcmdldC5zY3JvbGxUb3AgPSBuZXh0QW5pbWF0ZVRvID09PSAnMTAwJScgPyB0YXJnZXQuc2Nyb2xsSGVpZ2h0IC0gdGFyZ2V0Lm9mZnNldEhlaWdodCA6IG5leHRBbmltYXRlVG87XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJlaGF2aW9yICE9PSAnc21vb3RoJyAmJlxuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdyZWFjdC1zY3JvbGwtdG8tYm90dG9tOiBQbGVhc2Ugc2V0IFwiYmVoYXZpb3JcIiB3aGVuIGNhbGxpbmcgXCJzY3JvbGxUb1wiLiBJbiBmdXR1cmUgdmVyc2lvbnMsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdpbGwgYmUgY2hhbmdlZCBmcm9tIHNtb290aCBzY3JvbGxpbmcgdG8gZGlzY3JldGUgc2Nyb2xsaW5nIHRvIGFsaWduIHdpdGggSFRNTCBTdGFuZGFyZC4nXG4gICAgICAgICAgKTtcblxuICAgICAgICBzZXRBbmltYXRlVG8obmV4dEFuaW1hdGVUbyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgaXMgZm9yIGhhbmRsaW5nIGEgY2FzZS4gV2hlbiBjYWxsaW5nIHNjcm9sbFRvKCcxMDAlJywgeyBiZWhhdmlvcjogJ2F1dG8nIH0pIG11bHRpcGxlIHRpbWVzLCBpdCB3b3VsZCBsb3NlIHN0aWNraW5lc3MuXG4gICAgICBpc0VuZChuZXh0QW5pbWF0ZVRvLCBtb2RlKSAmJiBzZXRTdGlja3kodHJ1ZSk7XG4gICAgfSxcbiAgICBbZGVidWcsIGhhbmRsZVNwaW5lVG9FbmQsIG1vZGUsIHNldEFuaW1hdGVUbywgc2V0U3RpY2t5LCB0YXJnZXRdXG4gICk7XG5cbiAgY29uc3Qgc2Nyb2xsVG9Cb3R0b20gPSB1c2VDYWxsYmFjayhcbiAgICAoeyBiZWhhdmlvciB9ID0ge30pID0+IHtcbiAgICAgIGRlYnVnKCgpID0+IFsnJWNzY3JvbGxUb0JvdHRvbSVjOiBDYWxsZWQnLCAuLi5zdHlsZUNvbnNvbGUoJ3llbGxvdycsICcnKV0pO1xuXG4gICAgICBiZWhhdmlvciAhPT0gJ3Ntb290aCcgJiZcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdyZWFjdC1zY3JvbGwtdG8tYm90dG9tOiBQbGVhc2Ugc2V0IFwiYmVoYXZpb3JcIiB3aGVuIGNhbGxpbmcgXCJzY3JvbGxUb0JvdHRvbVwiLiBJbiBmdXR1cmUgdmVyc2lvbnMsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdpbGwgYmUgY2hhbmdlZCBmcm9tIHNtb290aCBzY3JvbGxpbmcgdG8gZGlzY3JldGUgc2Nyb2xsaW5nIHRvIGFsaWduIHdpdGggSFRNTCBTdGFuZGFyZC4nXG4gICAgICAgICk7XG5cbiAgICAgIHNjcm9sbFRvKCcxMDAlJywgeyBiZWhhdmlvcjogYmVoYXZpb3IgfHwgJ3Ntb290aCcgfSk7XG4gICAgfSxcbiAgICBbZGVidWcsIHNjcm9sbFRvXVxuICApO1xuXG4gIGNvbnN0IHNjcm9sbFRvVG9wID0gdXNlQ2FsbGJhY2soXG4gICAgKHsgYmVoYXZpb3IgfSA9IHt9KSA9PiB7XG4gICAgICBkZWJ1ZygoKSA9PiBbJyVjc2Nyb2xsVG9Ub3AlYzogQ2FsbGVkJywgLi4uc3R5bGVDb25zb2xlKCd5ZWxsb3cnLCAnJyldKTtcblxuICAgICAgYmVoYXZpb3IgIT09ICdzbW9vdGgnICYmXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAncmVhY3Qtc2Nyb2xsLXRvLWJvdHRvbTogUGxlYXNlIHNldCBcImJlaGF2aW9yXCIgd2hlbiBjYWxsaW5nIFwic2Nyb2xsVG9Ub3BcIi4gSW4gZnV0dXJlIHZlcnNpb25zLCB0aGUgZGVmYXVsdCBiZWhhdmlvciB3aWxsIGJlIGNoYW5nZWQgZnJvbSBzbW9vdGggc2Nyb2xsaW5nIHRvIGRpc2NyZXRlIHNjcm9sbGluZyB0byBhbGlnbiB3aXRoIEhUTUwgU3RhbmRhcmQuJ1xuICAgICAgICApO1xuXG4gICAgICBzY3JvbGxUbygwLCB7IGJlaGF2aW9yOiBiZWhhdmlvciB8fCAnc21vb3RoJyB9KTtcbiAgICB9LFxuICAgIFtkZWJ1Zywgc2Nyb2xsVG9dXG4gICk7XG5cbiAgY29uc3Qgc2Nyb2xsVG9FbmQgPSB1c2VDYWxsYmFjayhcbiAgICAoeyBiZWhhdmlvciB9ID0ge30pID0+IHtcbiAgICAgIGRlYnVnKCgpID0+IFsnJWNzY3JvbGxUb0VuZCVjOiBDYWxsZWQnLCAuLi5zdHlsZUNvbnNvbGUoJ3llbGxvdycsICcnKV0pO1xuXG4gICAgICBiZWhhdmlvciAhPT0gJ3Ntb290aCcgJiZcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdyZWFjdC1zY3JvbGwtdG8tYm90dG9tOiBQbGVhc2Ugc2V0IFwiYmVoYXZpb3JcIiB3aGVuIGNhbGxpbmcgXCJzY3JvbGxUb0VuZFwiLiBJbiBmdXR1cmUgdmVyc2lvbnMsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdpbGwgYmUgY2hhbmdlZCBmcm9tIHNtb290aCBzY3JvbGxpbmcgdG8gZGlzY3JldGUgc2Nyb2xsaW5nIHRvIGFsaWduIHdpdGggSFRNTCBTdGFuZGFyZC4nXG4gICAgICAgICk7XG5cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IGJlaGF2aW9yOiBiZWhhdmlvciB8fCAnc21vb3RoJyB9O1xuXG4gICAgICBtb2RlID09PSBNT0RFX1RPUCA/IHNjcm9sbFRvVG9wKG9wdGlvbnMpIDogc2Nyb2xsVG9Cb3R0b20ob3B0aW9ucyk7XG4gICAgfSxcbiAgICBbZGVidWcsIG1vZGUsIHNjcm9sbFRvQm90dG9tLCBzY3JvbGxUb1RvcF1cbiAgKTtcblxuICBjb25zdCBzY3JvbGxUb1N0YXJ0ID0gdXNlQ2FsbGJhY2soXG4gICAgKHsgYmVoYXZpb3IgfSA9IHt9KSA9PiB7XG4gICAgICBkZWJ1ZygoKSA9PiBbJyVjc2Nyb2xsVG9TdGFydCVjOiBDYWxsZWQnLCAuLi5zdHlsZUNvbnNvbGUoJ3llbGxvdycsICcnKV0pO1xuXG4gICAgICBiZWhhdmlvciAhPT0gJ3Ntb290aCcgJiZcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdyZWFjdC1zY3JvbGwtdG8tYm90dG9tOiBQbGVhc2Ugc2V0IFwiYmVoYXZpb3JcIiB3aGVuIGNhbGxpbmcgXCJzY3JvbGxUb1N0YXJ0XCIuIEluIGZ1dHVyZSB2ZXJzaW9ucywgdGhlIGRlZmF1bHQgYmVoYXZpb3Igd2lsbCBiZSBjaGFuZ2VkIGZyb20gc21vb3RoIHNjcm9sbGluZyB0byBkaXNjcmV0ZSBzY3JvbGxpbmcgdG8gYWxpZ24gd2l0aCBIVE1MIFN0YW5kYXJkLidcbiAgICAgICAgKTtcblxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgYmVoYXZpb3I6IGJlaGF2aW9yIHx8ICdzbW9vdGgnIH07XG5cbiAgICAgIG1vZGUgPT09IE1PREVfVE9QID8gc2Nyb2xsVG9Cb3R0b20ob3B0aW9ucykgOiBzY3JvbGxUb1RvcChvcHRpb25zKTtcbiAgICB9LFxuICAgIFtkZWJ1ZywgbW9kZSwgc2Nyb2xsVG9Cb3R0b20sIHNjcm9sbFRvVG9wXVxuICApO1xuXG4gIGNvbnN0IHNjcm9sbFRvU3RpY2t5ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIGlmIChpbml0aWFsU2Nyb2xsQmVoYXZpb3JSZWYuY3VycmVudCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIGRlYnVnKCgpID0+IFtgJWN0YXJnZXQgY2hhbmdlZCVjOiBJbml0aWFsIHNjcm9sbGAsIC4uLnN0eWxlQ29uc29sZSgnYmx1ZScpXSk7XG5cbiAgICAgICAgdGFyZ2V0LnNjcm9sbFRvcCA9IG1vZGUgPT09IE1PREVfVE9QID8gMCA6IHRhcmdldC5zY3JvbGxIZWlnaHQgLSB0YXJnZXQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBpbml0aWFsU2Nyb2xsQmVoYXZpb3JSZWYuY3VycmVudCA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBpcyB2ZXJ5IHNpbWlsYXIgdG8gc2Nyb2xsVG9FbmQoKS5cbiAgICAgIC8vIEluc3RlYWQgb2Ygc2Nyb2xsaW5nIHRvIGVuZCwgaXQgd2lsbCBjYWxsIHByb3BzLnNjcm9sbGVyKCkgdG8gZGV0ZXJtaW5lcyBob3cgZmFyIGl0IHNob3VsZCBzY3JvbGwuXG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIGNvdWxkIGJlIGNhbGxlZCB3aGlsZSBpdCBpcyBhdXRvLXNjcm9sbGluZy5cblxuICAgICAgY29uc3QgeyBjdXJyZW50OiBhbmltYXRlRnJvbSB9ID0gYW5pbWF0ZUZyb21SZWY7XG4gICAgICBjb25zdCB7IG9mZnNldEhlaWdodCwgc2Nyb2xsSGVpZ2h0LCBzY3JvbGxUb3AgfSA9IHRhcmdldDtcblxuICAgICAgY29uc3QgbWF4VmFsdWUgPSBtb2RlID09PSBNT0RFX1RPUCA/IDAgOiBNYXRoLm1heCgwLCBzY3JvbGxIZWlnaHQgLSBvZmZzZXRIZWlnaHQgLSBzY3JvbGxUb3ApO1xuICAgICAgY29uc3QgbWluVmFsdWUgPSBNYXRoLm1heCgwLCBhbmltYXRlRnJvbSAtIHNjcm9sbFRvcCk7XG5cbiAgICAgIGNvbnN0IHJhd05leHRWYWx1ZSA9IHNjcm9sbGVyKHsgbWF4VmFsdWUsIG1pblZhbHVlLCBvZmZzZXRIZWlnaHQsIHNjcm9sbEhlaWdodCwgc2Nyb2xsVG9wIH0pO1xuXG4gICAgICBjb25zdCBuZXh0VmFsdWUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXhWYWx1ZSwgcmF3TmV4dFZhbHVlKSk7XG5cbiAgICAgIGxldCBuZXh0QW5pbWF0ZVRvO1xuXG4gICAgICBpZiAobW9kZSA9PT0gTU9ERV9UT1AgfHwgbmV4dFZhbHVlICE9PSBtYXhWYWx1ZSkge1xuICAgICAgICBuZXh0QW5pbWF0ZVRvID0gc2Nyb2xsVG9wICsgbmV4dFZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2hlbiBzY3JvbGxpbmcgdG8gYm90dG9tLCB3ZSBzaG91bGQgc2Nyb2xsIHRvIFwiMTAwJVwiLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGlmIHdlIHNjcm9sbCB0byBhbnkgbnVtYmVyLCBpdCB3aWxsIGxvc2Ugc3RpY2tpbmVzcyB3aGVuIGVsZW1lbnRzIGFyZSBhZGRpbmcgdG9vIGZhc3QuXG4gICAgICAgIC8vIFwiMTAwJVwiIGlzIGEgc3BlY2lhbCBhcmd1bWVudCBpbnRlbmRlZCB0byBtYWtlIHN1cmUgc3RpY2tpbmVzcyBpcyBub3QgbG9zdCB3aGlsZSBuZXcgZWxlbWVudHMgYXJlIGJlaW5nIGFkZGVkLlxuICAgICAgICBuZXh0QW5pbWF0ZVRvID0gJzEwMCUnO1xuICAgICAgfVxuXG4gICAgICBkZWJ1ZygoKSA9PiBbXG4gICAgICAgIFtcbiAgICAgICAgICBgJWNzY3JvbGxUb1N0aWNreSVjOiBXaWxsIGFuaW1hdGUgZnJvbSAlYyR7YW5pbWF0ZUZyb219cHglYyB0byAlYyR7XG4gICAgICAgICAgICB0eXBlb2YgbmV4dEFuaW1hdGVUbyA9PT0gJ251bWJlcicgPyBuZXh0QW5pbWF0ZVRvICsgJ3B4JyA6IG5leHRBbmltYXRlVG8ucmVwbGFjZSgvJS9ndSwgJyUlJylcbiAgICAgICAgICB9JWMgKCVjJHsobmV4dEFuaW1hdGVUbyA9PT0gJzEwMCUnID8gbWF4VmFsdWUgOiBuZXh0QW5pbWF0ZVRvKSArIGFuaW1hdGVGcm9tfXB4JWMpYCxcbiAgICAgICAgICAuLi5zdHlsZUNvbnNvbGUoJ29yYW5nZScpLFxuICAgICAgICAgIC4uLnN0eWxlQ29uc29sZSgncHVycGxlJyksXG4gICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdwdXJwbGUnKSxcbiAgICAgICAgICAuLi5zdHlsZUNvbnNvbGUoJ3B1cnBsZScpXG4gICAgICAgIF0sXG4gICAgICAgIHtcbiAgICAgICAgICBhbmltYXRlRnJvbSxcbiAgICAgICAgICBtYXhWYWx1ZSxcbiAgICAgICAgICBtaW5WYWx1ZSxcbiAgICAgICAgICBuZXh0QW5pbWF0ZVRvLFxuICAgICAgICAgIG5leHRWYWx1ZSxcbiAgICAgICAgICBvZmZzZXRIZWlnaHQsXG4gICAgICAgICAgcmF3TmV4dFZhbHVlLFxuICAgICAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgICAgICBzY3JvbGxUb3BcbiAgICAgICAgfVxuICAgICAgXSk7XG5cbiAgICAgIHNjcm9sbFRvKG5leHRBbmltYXRlVG8sIHsgYmVoYXZpb3I6ICdzbW9vdGgnIH0pO1xuICAgIH1cbiAgfSwgW2FuaW1hdGVGcm9tUmVmLCBkZWJ1ZywgbW9kZSwgc2Nyb2xsZXIsIHNjcm9sbFRvLCB0YXJnZXRdKTtcblxuICBjb25zdCBoYW5kbGVTY3JvbGwgPSB1c2VDYWxsYmFjayhcbiAgICAoeyB0aW1lU3RhbXBMb3cgfSkgPT4ge1xuICAgICAgLy8gQ3VycmVudGx5LCB0aGVyZSBhcmUgbm8gcmVsaWFibGUgd2F5IHRvIGNoZWNrIGlmIHRoZSBcInNjcm9sbFwiIGV2ZW50IGlzIHRyaWdnZXIgZHVlIHRvXG4gICAgICAvLyB1c2VyIGdlc3R1cmUsIHByb2dyYW1tYXRpYyBzY3JvbGxpbmcsIG9yIENocm9tZS1zeW50aGVzaXplZCBcInNjcm9sbFwiIGV2ZW50IHRvIGNvbXBlbnNhdGUgc2l6ZSBjaGFuZ2UuXG4gICAgICAvLyBUaHVzLCB3ZSB1c2Ugb3VyIGJlc3QtZWZmb3J0IHRvIGd1ZXNzIGlmIGl0IGlzIHRyaWdnZXJlZCBieSB1c2VyIGdlc3R1cmUsIGFuZCBkaXNhYmxlIHN0aWNreSBpZiBpdCBpcyBoZWFkaW5nIHRvd2FyZHMgdGhlIHN0YXJ0IGRpcmVjdGlvbi5cblxuICAgICAgaWYgKHRpbWVTdGFtcExvdyA8PSBpZ25vcmVTY3JvbGxFdmVudEJlZm9yZVJlZi5jdXJyZW50IHx8ICF0YXJnZXQpIHtcbiAgICAgICAgLy8gU2luY2Ugd2UgZGVib3VuY2UgXCJzY3JvbGxcIiBldmVudCwgdGhpcyBoYW5kbGVyIG1pZ2h0IGJlIGNhbGxlZCBhZnRlciBzcGluZVRvLm9uRW5kIChhLmsuYS4gYXJ0aWZpY2lhbCBzY3JvbGxpbmcpLlxuICAgICAgICAvLyBXZSBzaG91bGQgaWdub3JlIGRlYm91bmNlZCBldmVudCBmaXJlZCBhZnRlciBzY3JvbGxFbmQsIGJlY2F1c2Ugd2l0aG91dCBza2lwcGluZyB0aGVtLCB0aGUgdXNlckluaXRpYXRlZFNjcm9sbCBjYWxjdWxhdGVkIGJlbG93IHdpbGwgbm90IGJlIGFjY3VyYXRlLlxuICAgICAgICAvLyBUaHVzLCBvbiBhIGZhc3QgbWFjaGluZSwgYWRkaW5nIGVsZW1lbnRzIHN1cGVyIGZhc3Qgd2lsbCBsb3NlIHRoZSBcInN0aWNraW5lc3NcIi5cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgYXRCb3R0b20sIGF0RW5kLCBhdFN0YXJ0LCBhdFRvcCB9ID0gY29tcHV0ZVZpZXdTdGF0ZSh7IG1vZGUsIHRhcmdldCB9KTtcblxuICAgICAgc2V0QXRCb3R0b20oYXRCb3R0b20pO1xuICAgICAgc2V0QXRFbmQoYXRFbmQpO1xuICAgICAgc2V0QXRTdGFydChhdFN0YXJ0KTtcbiAgICAgIHNldEF0VG9wKGF0VG9wKTtcblxuICAgICAgLy8gQ2hyb21lIHdpbGwgZW1pdCBcInN5bnRoZXRpY1wiIHNjcm9sbCBldmVudCBpZiB0aGUgY29udGFpbmVyIGlzIHJlc2l6ZWQgb3IgYW4gZWxlbWVudCBpcyBhZGRlZFxuICAgICAgLy8gV2UgbmVlZCB0byBpZ25vcmUgdGhlc2UgXCJzeW50aGV0aWNcIiBldmVudHNcbiAgICAgIC8vIFJlcHJvOiBJbiBwbGF5Z3JvdW5kLCBwcmVzcyA0LTEtNS0xLTEgKHNtYWxsLCBhZGQgb25lLCBub3JtYWwsIGFkZCBvbmUsIGFkZCBvbmUpXG4gICAgICAvLyAgICAgICAgTm9tYXR0ZXIgaG93IGZhc3Qgb3Igc2xvdyB0aGUgc2VxdWVuY2UgaXMgYmVpbmcgcHJlc3NlZCwgaXQgc2hvdWxkIHN0aWxsIHN0aWNrIHRvIHRoZSBib3R0b21cbiAgICAgIGNvbnN0IHsgb2Zmc2V0SGVpZ2h0OiBuZXh0T2Zmc2V0SGVpZ2h0LCBzY3JvbGxIZWlnaHQ6IG5leHRTY3JvbGxIZWlnaHQgfSA9IHRhcmdldDtcbiAgICAgIGNvbnN0IHsgY3VycmVudDogb2Zmc2V0SGVpZ2h0IH0gPSBvZmZzZXRIZWlnaHRSZWY7XG4gICAgICBjb25zdCB7IGN1cnJlbnQ6IHNjcm9sbEhlaWdodCB9ID0gc2Nyb2xsSGVpZ2h0UmVmO1xuICAgICAgY29uc3Qgb2Zmc2V0SGVpZ2h0Q2hhbmdlZCA9IG5leHRPZmZzZXRIZWlnaHQgIT09IG9mZnNldEhlaWdodDtcbiAgICAgIGNvbnN0IHNjcm9sbEhlaWdodENoYW5nZWQgPSBuZXh0U2Nyb2xsSGVpZ2h0ICE9PSBzY3JvbGxIZWlnaHQ7XG5cbiAgICAgIGlmIChvZmZzZXRIZWlnaHRDaGFuZ2VkKSB7XG4gICAgICAgIG9mZnNldEhlaWdodFJlZi5jdXJyZW50ID0gbmV4dE9mZnNldEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjcm9sbEhlaWdodENoYW5nZWQpIHtcbiAgICAgICAgc2Nyb2xsSGVpZ2h0UmVmLmN1cnJlbnQgPSBuZXh0U2Nyb2xsSGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICAvLyBTdGlja3kgbWVhbnM6XG4gICAgICAvLyAtIElmIGl0IGlzIHNjcm9sbGVkIHByb2dyYW1hdGljYWxseSwgd2UgYXJlIHN0aWxsIGluIHN0aWNreSBtb2RlXG4gICAgICAvLyAtIElmIGl0IGlzIHNjcm9sbGVkIGJ5IHRoZSB1c2VyLCB0aGVuIHN0aWNreSBtZWFucyBpZiB3ZSBhcmUgYXQgdGhlIGVuZFxuXG4gICAgICAvLyBPbmx5IHVwZGF0ZSBzdGlja2luZXNzIGlmIHRoZSBzY3JvbGwgZXZlbnQgaXMgbm90IGR1ZSB0byBzeW50aGV0aWMgc2Nyb2xsIGRvbmUgYnkgQ2hyb21lXG4gICAgICBpZiAoIW9mZnNldEhlaWdodENoYW5nZWQgJiYgIXNjcm9sbEhlaWdodENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgYXJlIHN0aWNreSBpZiB3ZSBhcmUgYW5pbWF0aW5nIHRvIHRoZSBlbmQsIG9yIHdlIGFyZSBhbHJlYWR5IGF0IHRoZSBlbmQuXG4gICAgICAgIC8vIFdlIGNhbiBiZSBcImFuaW1hdGluZyBidXQgbm90IHN0aWNreVwiIGJ5IGNhbGxpbmcgXCJzY3JvbGxUbygxMDApXCIgd2hlcmUgdGhlIGNvbnRhaW5lciBzY3JvbGxIZWlnaHQgaXMgMjAwcHguXG4gICAgICAgIGNvbnN0IG5leHRTdGlja3kgPSAoYW5pbWF0aW5nICYmIGlzRW5kKGFuaW1hdGVUbywgbW9kZSkpIHx8IGF0RW5kO1xuXG4gICAgICAgIGlmIChzdGlja3kgIT09IG5leHRTdGlja3kpIHtcbiAgICAgICAgICBkZWJ1ZygoKSA9PiBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIGAlY29uU2Nyb2xsJWM6ICVjc2V0U3RpY2t5JWMoJWMke25leHRTdGlja3l9JWMpYCxcbiAgICAgICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdyZWQnKSxcbiAgICAgICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdyZWQnKSxcbiAgICAgICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdwdXJwbGUnKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgYChhbmltYXRpbmcgPSAlYyR7YW5pbWF0aW5nfSVjICYmIGlzRW5kID0gJWMke2lzRW5kKGFuaW1hdGVUbywgbW9kZSl9JWMpIHx8IGF0RW5kID0gJWMke2F0RW5kfSVjYCxcbiAgICAgICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdwdXJwbGUnKSxcbiAgICAgICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdwdXJwbGUnKSxcbiAgICAgICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdwdXJwbGUnKSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFuaW1hdGluZyxcbiAgICAgICAgICAgICAgICBhbmltYXRlVG8sXG4gICAgICAgICAgICAgICAgYXRFbmQsXG4gICAgICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgICAgICBvZmZzZXRIZWlnaHQ6IHRhcmdldC5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0OiB0YXJnZXQuc2Nyb2xsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIHN0aWNreSxcbiAgICAgICAgICAgICAgICBuZXh0U3RpY2t5XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICBdKTtcblxuICAgICAgICAgIHNldFN0aWNreShuZXh0U3RpY2t5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdGlja3kpIHtcbiAgICAgICAgZGVidWcoKCkgPT4gW1xuICAgICAgICAgIFtcbiAgICAgICAgICAgIGAlY29uU2Nyb2xsJWM6IFNpemUgY2hhbmdlZCB3aGlsZSBzdGlja3ksIGNhbGxpbmcgJWNzY3JvbGxUb1N0aWNreSgpJWNgLFxuICAgICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdyZWQnKSxcbiAgICAgICAgICAgIC4uLnN0eWxlQ29uc29sZSgnb3JhbmdlJyksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG9mZnNldEhlaWdodENoYW5nZWQsXG4gICAgICAgICAgICAgIHNjcm9sbEhlaWdodENoYW5nZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5leHRPZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICBwcmV2T2Zmc2V0SGVpZ2h0OiBvZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICBuZXh0U2Nyb2xsSGVpZ2h0LFxuICAgICAgICAgICAgcHJldlNjcm9sbEhlaWdodDogc2Nyb2xsSGVpZ2h0XG4gICAgICAgICAgfVxuICAgICAgICBdKTtcblxuICAgICAgICBzY3JvbGxUb1N0aWNreSgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHNjcm9sbFRvcDogYWN0dWFsU2Nyb2xsVG9wIH0gPSB0YXJnZXQ7XG5cbiAgICAgIHNjcm9sbFBvc2l0aW9uT2JzZXJ2ZXJzUmVmLmN1cnJlbnQuZm9yRWFjaChvYnNlcnZlciA9PiBvYnNlcnZlcih7IHNjcm9sbFRvcDogYWN0dWFsU2Nyb2xsVG9wIH0pKTtcbiAgICB9LFxuICAgIFtcbiAgICAgIGFuaW1hdGVUbyxcbiAgICAgIGFuaW1hdGluZyxcbiAgICAgIGRlYnVnLFxuICAgICAgaWdub3JlU2Nyb2xsRXZlbnRCZWZvcmVSZWYsXG4gICAgICBtb2RlLFxuICAgICAgb2Zmc2V0SGVpZ2h0UmVmLFxuICAgICAgc2Nyb2xsSGVpZ2h0UmVmLFxuICAgICAgc2Nyb2xsUG9zaXRpb25PYnNlcnZlcnNSZWYsXG4gICAgICBzY3JvbGxUb1N0aWNreSxcbiAgICAgIHNldEF0Qm90dG9tLFxuICAgICAgc2V0QXRFbmQsXG4gICAgICBzZXRBdFN0YXJ0LFxuICAgICAgc2V0QXRUb3AsXG4gICAgICBzZXRTdGlja3ksXG4gICAgICBzdGlja3ksXG4gICAgICB0YXJnZXRcbiAgICBdXG4gICk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICBsZXQgc3RpY2t5QnV0Tm90QXRFbmRTaW5jZSA9IGZhbHNlO1xuXG4gICAgICBjb25zdCB0aW1lb3V0ID0gc2V0SW1tZWRpYXRlSW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBpZiAoc3RpY2t5KSB7XG4gICAgICAgICAgaWYgKCFjb21wdXRlVmlld1N0YXRlKHsgbW9kZSwgdGFyZ2V0IH0pLmF0RW5kKSB7XG4gICAgICAgICAgICBpZiAoIXN0aWNreUJ1dE5vdEF0RW5kU2luY2UpIHtcbiAgICAgICAgICAgICAgc3RpY2t5QnV0Tm90QXRFbmRTaW5jZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKERhdGUubm93KCkgLSBzdGlja3lCdXROb3RBdEVuZFNpbmNlID4gU0NST0xMX0RFQ0lTSU9OX0RVUkFUSU9OKSB7XG4gICAgICAgICAgICAgIC8vIFF1aXJrczogSW4gRmlyZWZveCwgYWZ0ZXIgdXNlciBzY3JvbGwgZG93biwgRmlyZWZveCBkbyB0d28gdGhpbmdzOlxuICAgICAgICAgICAgICAvLyAgICAgICAgIDEuIFNldCB0byBhIG5ldyBcInNjcm9sbFRvcFwiXG4gICAgICAgICAgICAgIC8vICAgICAgICAgMi4gRmlyZSBcInNjcm9sbFwiIGV2ZW50XG4gICAgICAgICAgICAgIC8vICAgICAgICAgRm9yIHdoYXQgd2Ugb2JzZXJ2ZWQsICMxIGlzIGZpcmVkIGFib3V0IDIwbXMgYmVmb3JlICMyLiBUaGVyZSBpcyBhIGNoYW5jZSB0aGF0IHRoaXMgc3RpY2t5Q2hlY2tUaW1lb3V0IGlzIGJlaW5nIHNjaGVkdWxlZCBiZXR3ZWVuIDEgYW5kIDIuXG4gICAgICAgICAgICAgIC8vICAgICAgICAgVGhhdCBtZWFucywgaWYgd2UganVzdCBsb29rIGF0ICMxIHRvIGRlY2lkZSBpZiB3ZSBzaG91bGQgc2Nyb2xsLCB3ZSB3aWxsIGFsd2F5cyBzY3JvbGwsIGluIG9wcG9zZSB0byB0aGUgdXNlcidzIGludGVudGlvbi5cbiAgICAgICAgICAgICAgLy8gUmVwcm86IE9wZW4gRmlyZWZveCwgc2V0IGNoZWNrSW50ZXJ2YWwgdG8gYSBsb3dlciBudW1iZXIsIGFuZCB0cnkgdG8gc2Nyb2xsIGJ5IGRyYWdnaW5nIHRoZSBzY3JvbGwgaGFuZGxlci4gSXQgd2lsbCBqdW1wIGJhY2suXG5cbiAgICAgICAgICAgICAgLy8gVGhlIFwiYW5pbWF0aW5nXCIgY2hlY2sgd2lsbCBtYWtlIHN1cmUgc3RpY2tpbmVzcyBpcyBub3QgbG9zdCB3aGVuIGVsZW1lbnRzIGFyZSBhZGRpbmcgYXQgYSB2ZXJ5IGZhc3QgcGFjZS5cbiAgICAgICAgICAgICAgaWYgKCFhbmltYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRlRnJvbVJlZi5jdXJyZW50ID0gdGFyZ2V0LnNjcm9sbFRvcDtcblxuICAgICAgICAgICAgICAgIGRlYnVnKCgpID0+IFtcbiAgICAgICAgICAgICAgICAgIGAlY0ludGVydmFsIGNoZWNrJWM6IFNob3VsZCBzdGlja3kgYnV0IG5vdCBhdCBlbmQsIGNhbGxpbmcgJWNzY3JvbGxUb1N0aWNreSgpJWMgdG8gc2Nyb2xsYCxcbiAgICAgICAgICAgICAgICAgIC4uLnN0eWxlQ29uc29sZSgnbmF2eScpLFxuICAgICAgICAgICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdvcmFuZ2UnKVxuICAgICAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICAgICAgc2Nyb2xsVG9TdGlja3koKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHN0aWNreUJ1dE5vdEF0RW5kU2luY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RpY2t5QnV0Tm90QXRFbmRTaW5jZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQuc2Nyb2xsSGVpZ2h0IDw9IHRhcmdldC5vZmZzZXRIZWlnaHQgJiYgIXN0aWNreSkge1xuICAgICAgICAgIC8vIFdoZW4gdGhlIGNvbnRhaW5lciBpcyBlbXB0aWVkLCB3ZSB3aWxsIHNldCBzdGlja3kgYmFjayB0byB0cnVlLlxuXG4gICAgICAgICAgc2V0U3RpY2t5KHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCBNYXRoLm1heChNSU5fQ0hFQ0tfSU5URVJWQUwsIGNoZWNrSW50ZXJ2YWwpIHx8IE1JTl9DSEVDS19JTlRFUlZBTCk7XG5cbiAgICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKHRpbWVvdXQpO1xuICAgIH1cbiAgfSwgW2FuaW1hdGluZywgY2hlY2tJbnRlcnZhbCwgZGVidWcsIG1vZGUsIHNjcm9sbFRvU3RpY2t5LCBzZXRTdGlja3ksIHN0aWNreSwgdGFyZ2V0XSk7XG5cbiAgY29uc3Qgc3R5bGVUb0NsYXNzTmFtZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGVtb3Rpb24gPVxuICAgICAgZW1vdGlvblBvb2xbbm9uY2VdIHx8XG4gICAgICAoZW1vdGlvblBvb2xbbm9uY2VdID0gY3JlYXRlRW1vdGlvbih7IGtleTogJ3JlYWN0LXNjcm9sbC10by1ib3R0b20tLWNzcy0nICsgY3JlYXRlQ1NTS2V5KCksIG5vbmNlIH0pKTtcblxuICAgIHJldHVybiBzdHlsZSA9PiBlbW90aW9uLmNzcyhzdHlsZSkgKyAnJztcbiAgfSwgW25vbmNlXSk7XG5cbiAgY29uc3QgaW50ZXJuYWxDb250ZXh0ID0gdXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgb2JzZXJ2ZVNjcm9sbFBvc2l0aW9uLFxuICAgICAgc2V0VGFyZ2V0LFxuICAgICAgc3R5bGVUb0NsYXNzTmFtZVxuICAgIH0pLFxuICAgIFtvYnNlcnZlU2Nyb2xsUG9zaXRpb24sIHNldFRhcmdldCwgc3R5bGVUb0NsYXNzTmFtZV1cbiAgKTtcblxuICBjb25zdCBzdGF0ZTFDb250ZXh0ID0gdXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgYXRCb3R0b20sXG4gICAgICBhdEVuZCxcbiAgICAgIGF0U3RhcnQsXG4gICAgICBhdFRvcCxcbiAgICAgIG1vZGVcbiAgICB9KSxcbiAgICBbYXRCb3R0b20sIGF0RW5kLCBhdFN0YXJ0LCBhdFRvcCwgbW9kZV1cbiAgKTtcblxuICBjb25zdCBzdGF0ZTJDb250ZXh0ID0gdXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgYW5pbWF0aW5nLFxuICAgICAgYW5pbWF0aW5nVG9FbmQ6IGFuaW1hdGluZyAmJiBpc0VuZChhbmltYXRlVG8sIG1vZGUpLFxuICAgICAgc3RpY2t5XG4gICAgfSksXG4gICAgW2FuaW1hdGluZywgYW5pbWF0ZVRvLCBkZWJ1ZywgbW9kZSwgc3RpY2t5XVxuICApO1xuXG4gIGNvbnN0IGNvbWJpbmVkU3RhdGVDb250ZXh0ID0gdXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgLi4uc3RhdGUxQ29udGV4dCxcbiAgICAgIC4uLnN0YXRlMkNvbnRleHRcbiAgICB9KSxcbiAgICBbc3RhdGUxQ29udGV4dCwgc3RhdGUyQ29udGV4dF1cbiAgKTtcblxuICBjb25zdCBmdW5jdGlvbkNvbnRleHQgPSB1c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBzY3JvbGxUbyxcbiAgICAgIHNjcm9sbFRvQm90dG9tLFxuICAgICAgc2Nyb2xsVG9FbmQsXG4gICAgICBzY3JvbGxUb1N0YXJ0LFxuICAgICAgc2Nyb2xsVG9Ub3BcbiAgICB9KSxcbiAgICBbc2Nyb2xsVG8sIHNjcm9sbFRvQm90dG9tLCBzY3JvbGxUb0VuZCwgc2Nyb2xsVG9TdGFydCwgc2Nyb2xsVG9Ub3BdXG4gICk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBXZSBuZWVkIHRvIHVwZGF0ZSB0aGUgXCJzY3JvbGxIZWlnaHRcIiB2YWx1ZSB0byBsYXRlc3Qgd2hlbiB0aGUgdXNlciBkbyBhIGZvY3VzIGluc2lkZSB0aGUgYm94LlxuICAgIC8vXG4gICAgLy8gVGhpcyBpcyBiZWNhdXNlOlxuICAgIC8vIC0gSW4gb3VyIGNvZGUgdGhhdCBtaXRpZ2F0ZSBDaHJvbWUgc3ludGhldGljIHNjcm9sbGluZywgdGhhdCBjb2RlIHdpbGwgbG9vayBhdCB3aGV0aGVyIFwic2Nyb2xsSGVpZ2h0XCIgdmFsdWUgaXMgbGF0ZXN0IG9yIG5vdC5cbiAgICAvLyAtIFRoYXQgY29kZSBvbmx5IHJ1biBvbiBcInNjcm9sbFwiIGV2ZW50LlxuICAgIC8vIC0gVGhhdCBtZWFucywgb24gZXZlcnkgXCJzY3JvbGxcIiBldmVudCwgaWYgdGhlIFwic2Nyb2xsSGVpZ2h0XCIgdmFsdWUgaXMgbm90IGxhdGVzdCwgd2Ugd2lsbCBza2lwIG1vZGlmeWluZyB0aGUgc3RpY2tpbmVzcy5cbiAgICAvLyAtIFRoYXQgbWVhbnMsIGlmIHRoZSB1c2VyIFwiZm9jdXNcIiB0byBhbiBlbGVtZW50IHRoYXQgY2F1c2UgdGhlIHNjcm9sbCB2aWV3IHRvIHNjcm9sbCB0byB0aGUgYm90dG9tLCB0aGUgdXNlciBhZ2VudCB3aWxsIGZpcmUgXCJzY3JvbGxcIiBldmVudC5cbiAgICAvLyAgIFNpbmNlIHRoZSBcInNjcm9sbEhlaWdodFwiIGlzIG5vdCBsYXRlc3QgdmFsdWUsIHRoaXMgXCJzY3JvbGxcIiBldmVudCB3aWxsIGJlIGlnbm9yZWQgYW5kIHN0aWNraW5lc3Mgd2lsbCBub3QgYmUgbW9kaWZpZWQuXG4gICAgLy8gLSBUaGF0IG1lYW5zLCBpZiB0aGUgdXNlciBcImZvY3VzXCIgdG8gYSBuZXdseSBhZGRlZCBlbGVtZW50IHRoYXQgaXMgYXQgdGhlIGVuZCBvZiB0aGUgc2Nyb2xsIHZpZXcsIHRoZSBcInNjcm9sbCB0byBib3R0b21cIiBidXR0b24gd2lsbCBjb250aW51ZSB0byBzaG93LlxuICAgIC8vXG4gICAgLy8gUmVwcm8gaW4gQ2hyb21lOlxuICAgIC8vIDEuIEZpbGwgdXAgYSBzY3JvbGwgdmlld1xuICAgIC8vIDIuIFNjcm9sbCB1cCwgdGhlIFwic2Nyb2xsIHRvIGJvdHRvbVwiIGJ1dHRvbiBzaG91bGQgc2hvdyB1cFxuICAgIC8vIDMuIENsaWNrIFwiQWRkIGEgYnV0dG9uXCJcbiAgICAvLyA0LiBDbGljayBvbiB0aGUgc2Nyb2xsIHZpZXcgKHRvIHBzZXVkby1mb2N1cyBvbiBpdClcbiAgICAvLyA1LiBQcmVzcyBUQUIsIHRoZSBzY3JvbGwgdmlldyB3aWxsIGJlIGF0IHRoZSBib3R0b21cbiAgICAvL1xuICAgIC8vIEV4cGVjdDpcbiAgICAvLyAtIFRoZSBcInNjcm9sbCB0byBib3R0b21cIiBidXR0b24gc2hvdWxkIGJlIGdvbmUuXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgY29uc3QgaGFuZGxlRm9jdXMgPSAoKSA9PiB7XG4gICAgICAgIHNjcm9sbEhlaWdodFJlZi5jdXJyZW50ID0gdGFyZ2V0LnNjcm9sbEhlaWdodDtcbiAgICAgIH07XG5cbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGhhbmRsZUZvY3VzLCB7IGNhcHR1cmU6IHRydWUsIHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgICAgIHJldHVybiAoKSA9PiB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBoYW5kbGVGb2N1cyk7XG4gICAgfVxuICB9LCBbdGFyZ2V0XSk7XG5cbiAgZGVidWcoKCkgPT4gW1xuICAgIFtgJWNSZW5kZXIlYzogUmVuZGVyYCwgLi4uc3R5bGVDb25zb2xlKCdjeWFuJywgJycpXSxcbiAgICB7XG4gICAgICBhbmltYXRlVG8sXG4gICAgICBhbmltYXRpbmcsXG4gICAgICBzdGlja3ksXG4gICAgICB0YXJnZXRcbiAgICB9XG4gIF0pO1xuXG4gIHJldHVybiAoXG4gICAgPEludGVybmFsQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17aW50ZXJuYWxDb250ZXh0fT5cbiAgICAgIDxGdW5jdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2Z1bmN0aW9uQ29udGV4dH0+XG4gICAgICAgIDxTdGF0ZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbWJpbmVkU3RhdGVDb250ZXh0fT5cbiAgICAgICAgICA8U3RhdGUxQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17c3RhdGUxQ29udGV4dH0+XG4gICAgICAgICAgICA8U3RhdGUyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17c3RhdGUyQ29udGV4dH0+XG4gICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAge3RhcmdldCAmJiA8RXZlbnRTcHkgZGVib3VuY2U9e2RlYm91bmNlfSBuYW1lPVwic2Nyb2xsXCIgb25FdmVudD17aGFuZGxlU2Nyb2xsfSB0YXJnZXQ9e3RhcmdldH0gLz59XG4gICAgICAgICAgICAgIHt0YXJnZXQgJiYgYW5pbWF0ZVRvICE9PSBudWxsICYmIChcbiAgICAgICAgICAgICAgICA8U3BpbmVUbyBuYW1lPVwic2Nyb2xsVG9wXCIgb25FbmQ9e2hhbmRsZVNwaW5lVG9FbmR9IHRhcmdldD17dGFyZ2V0fSB2YWx1ZT17YW5pbWF0ZVRvfSAvPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9TdGF0ZTJDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgIDwvU3RhdGUxQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgPC9TdGF0ZUNvbnRleHQuUHJvdmlkZXI+XG4gICAgICA8L0Z1bmN0aW9uQ29udGV4dC5Qcm92aWRlcj5cbiAgICA8L0ludGVybmFsQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn07XG5cbkNvbXBvc2VyLmRlZmF1bHRQcm9wcyA9IHtcbiAgY2hlY2tJbnRlcnZhbDogMTAwLFxuICBjaGlsZHJlbjogdW5kZWZpbmVkLFxuICBkZWJvdW5jZTogMTcsXG4gIGRlYnVnOiBmYWxzZSxcbiAgaW5pdGlhbFNjcm9sbEJlaGF2aW9yOiAnc21vb3RoJyxcbiAgbW9kZTogdW5kZWZpbmVkLFxuICBub25jZTogdW5kZWZpbmVkLFxuICBzY3JvbGxlcjogREVGQVVMVF9TQ1JPTExFUlxufTtcblxuQ29tcG9zZXIucHJvcFR5cGVzID0ge1xuICBjaGVja0ludGVydmFsOiBQcm9wVHlwZXMubnVtYmVyLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLmFueSxcbiAgZGVib3VuY2U6IFByb3BUeXBlcy5udW1iZXIsXG4gIGRlYnVnOiBQcm9wVHlwZXMuYm9vbCxcbiAgaW5pdGlhbFNjcm9sbEJlaGF2aW9yOiBQcm9wVHlwZXMub25lT2YoWydhdXRvJywgJ3Ntb290aCddKSxcbiAgbW9kZTogUHJvcFR5cGVzLm9uZU9mKFsnYm90dG9tJywgJ3RvcCddKSxcbiAgbm9uY2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHNjcm9sbGVyOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9zZXI7XG4iXX0=