{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _createEmotion = _interopRequireDefault(require(\"create-emotion\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _createCSSKey = _interopRequireDefault(require(\"../createCSSKey\"));\n\nvar _debug = _interopRequireDefault(require(\"../utils/debug\"));\n\nvar _EventSpy = _interopRequireDefault(require(\"../EventSpy\"));\n\nvar _FunctionContext = _interopRequireDefault(require(\"./FunctionContext\"));\n\nvar _InternalContext = _interopRequireDefault(require(\"./InternalContext\"));\n\nvar _SpineTo = _interopRequireDefault(require(\"../SpineTo\"));\n\nvar _State1Context = _interopRequireDefault(require(\"./State1Context\"));\n\nvar _State2Context = _interopRequireDefault(require(\"./State2Context\"));\n\nvar _StateContext = _interopRequireDefault(require(\"./StateContext\"));\n\nvar _styleConsole = _interopRequireDefault(require(\"../utils/styleConsole\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar DEFAULT_SCROLLER = function DEFAULT_SCROLLER() {\n  return Infinity;\n};\n\nvar MIN_CHECK_INTERVAL = 17; // 1 frame\n\nvar MODE_BOTTOM = 'bottom';\nvar MODE_TOP = 'top';\nvar NEAR_END_THRESHOLD = 1;\nvar SCROLL_DECISION_DURATION = 34; // 2 frames\n// We pool the emotion object by nonce.\n// This is to make sure we don't generate too many unneeded <style> tags.\n\nvar emotionPool = {};\n\nfunction setImmediateInterval(fn, ms) {\n  fn();\n  return setInterval(fn, ms);\n}\n\nfunction computeViewState(_ref) {\n  var mode = _ref.mode,\n      _ref$target = _ref.target,\n      offsetHeight = _ref$target.offsetHeight,\n      scrollHeight = _ref$target.scrollHeight,\n      scrollTop = _ref$target.scrollTop;\n  var atBottom = scrollHeight - scrollTop - offsetHeight < NEAR_END_THRESHOLD;\n  var atTop = scrollTop < NEAR_END_THRESHOLD;\n  var atEnd = mode === MODE_TOP ? atTop : atBottom;\n  var atStart = mode !== MODE_TOP ? atTop : atBottom;\n  return {\n    atBottom: atBottom,\n    atEnd: atEnd,\n    atStart: atStart,\n    atTop: atTop\n  };\n}\n\nfunction isEnd(animateTo, mode) {\n  return animateTo === (mode === MODE_TOP ? 0 : '100%');\n}\n\nvar Composer = function Composer(_ref2) {\n  var checkInterval = _ref2.checkInterval,\n      children = _ref2.children,\n      debounce = _ref2.debounce,\n      forceDebug = _ref2.debug,\n      initialScrollBehavior = _ref2.initialScrollBehavior,\n      mode = _ref2.mode,\n      nonce = _ref2.nonce,\n      scroller = _ref2.scroller;\n  var debug = (0, _react.useMemo)(function () {\n    return (0, _debug.default)(\"<ScrollToBottom>\", {\n      force: forceDebug\n    });\n  }, [forceDebug]);\n  mode = mode === MODE_TOP ? MODE_TOP : MODE_BOTTOM;\n  var ignoreScrollEventBeforeRef = (0, _react.useRef)(0);\n  var initialScrollBehaviorRef = (0, _react.useRef)(initialScrollBehavior);\n\n  var _useState = (0, _react.useState)(mode === MODE_TOP ? 0 : '100%'),\n      _useState2 = _slicedToArray(_useState, 2),\n      animateTo = _useState2[0],\n      setAnimateTo = _useState2[1];\n\n  var _useState3 = (0, _react.useState)(null),\n      _useState4 = _slicedToArray(_useState3, 2),\n      target = _useState4[0],\n      setTarget = _useState4[1]; // Internal context\n\n\n  var animateFromRef = (0, _react.useRef)(0);\n  var offsetHeightRef = (0, _react.useRef)(0);\n  var scrollHeightRef = (0, _react.useRef)(0); // State context\n\n  var animating = animateTo !== null;\n\n  var _useState5 = (0, _react.useState)(true),\n      _useState6 = _slicedToArray(_useState5, 2),\n      atBottom = _useState6[0],\n      setAtBottom = _useState6[1];\n\n  var _useState7 = (0, _react.useState)(true),\n      _useState8 = _slicedToArray(_useState7, 2),\n      atEnd = _useState8[0],\n      setAtEnd = _useState8[1];\n\n  var _useState9 = (0, _react.useState)(true),\n      _useState10 = _slicedToArray(_useState9, 2),\n      atTop = _useState10[0],\n      setAtTop = _useState10[1];\n\n  var _useState11 = (0, _react.useState)(false),\n      _useState12 = _slicedToArray(_useState11, 2),\n      atStart = _useState12[0],\n      setAtStart = _useState12[1];\n\n  var _useState13 = (0, _react.useState)(true),\n      _useState14 = _slicedToArray(_useState13, 2),\n      sticky = _useState14[0],\n      setSticky = _useState14[1]; // High-rate state context\n\n\n  var scrollPositionObserversRef = (0, _react.useRef)([]);\n  var observeScrollPosition = (0, _react.useCallback)(function (fn) {\n    scrollPositionObserversRef.current.push(fn);\n    target && fn({\n      scrollTop: target.scrollTop\n    });\n    return function () {\n      var scrollPositionObservers = scrollPositionObserversRef.current;\n      var index = scrollPositionObservers.indexOf(fn);\n      ~index && scrollPositionObservers.splice(index, 1);\n    };\n  }, [scrollPositionObserversRef, target]);\n  var handleSpineToEnd = (0, _react.useCallback)(function () {\n    debug(function () {\n      return ['%cSpineTo%c: %conEnd%c is fired.'].concat(_toConsumableArray((0, _styleConsole.default)('magenta')), _toConsumableArray((0, _styleConsole.default)('orange')), [{\n        animateTo: animateTo\n      }]);\n    });\n    ignoreScrollEventBeforeRef.current = Date.now(); // handleScrollEnd may end at a position which should lose stickiness.\n    // In that case, we will need to set sticky to false to stop the interval check.\n    // Test case:\n    // 1. Add a scroller that always return 0\n    // 2. Show a panel with mode === MODE_BOTTOM\n    // 3. Programmatically scroll to 0 (set element.scrollTop = 0)\n    // Expected: it should not repetitively call scrollTo(0)\n    //           it should set stickiness to false\n\n    isEnd(animateTo, mode) || setSticky(false);\n    setAnimateTo(null);\n  }, [animateTo, debug, ignoreScrollEventBeforeRef, mode, setAnimateTo, setSticky]); // Function context\n\n  var scrollTo = (0, _react.useCallback)(function (nextAnimateTo) {\n    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        behavior = _ref3.behavior;\n\n    if (typeof nextAnimateTo !== 'number' && nextAnimateTo !== '100%') {\n      return console.warn('react-scroll-to-bottom: Arguments passed to scrollTo() must be either number or \"100%\".');\n    } // If it is trying to scroll to a position which is not \"atEnd\", it should set sticky to false after scroll ended.\n\n\n    debug(function () {\n      return [[\"%cscrollTo%c: Will scroll to %c\".concat(typeof nextAnimateTo === 'number' ? nextAnimateTo + 'px' : nextAnimateTo.replace(/%/g, '%%'), \"%c\")].concat(_toConsumableArray((0, _styleConsole.default)('lime', '')), _toConsumableArray((0, _styleConsole.default)('purple'))), {\n        behavior: behavior,\n        nextAnimateTo: nextAnimateTo,\n        target: target\n      }];\n    });\n\n    if (behavior === 'auto') {\n      // Stop any existing animation\n      handleSpineToEnd();\n\n      if (target) {\n        // Jump to the scroll position\n        target.scrollTop = nextAnimateTo === '100%' ? target.scrollHeight - target.offsetHeight : nextAnimateTo;\n      }\n    } else {\n      behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollTo\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');\n      setAnimateTo(nextAnimateTo);\n    } // This is for handling a case. When calling scrollTo('100%', { behavior: 'auto' }) multiple times, it would lose stickiness.\n\n\n    isEnd(nextAnimateTo, mode) && setSticky(true);\n  }, [debug, handleSpineToEnd, mode, setAnimateTo, setSticky, target]);\n  var scrollToBottom = (0, _react.useCallback)(function () {\n    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        behavior = _ref4.behavior;\n\n    debug(function () {\n      return ['%cscrollToBottom%c: Called'].concat(_toConsumableArray((0, _styleConsole.default)('yellow', '')));\n    });\n    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToBottom\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');\n    scrollTo('100%', {\n      behavior: behavior || 'smooth'\n    });\n  }, [debug, scrollTo]);\n  var scrollToTop = (0, _react.useCallback)(function () {\n    var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        behavior = _ref5.behavior;\n\n    debug(function () {\n      return ['%cscrollToTop%c: Called'].concat(_toConsumableArray((0, _styleConsole.default)('yellow', '')));\n    });\n    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToTop\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');\n    scrollTo(0, {\n      behavior: behavior || 'smooth'\n    });\n  }, [debug, scrollTo]);\n  var scrollToEnd = (0, _react.useCallback)(function () {\n    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        behavior = _ref6.behavior;\n\n    debug(function () {\n      return ['%cscrollToEnd%c: Called'].concat(_toConsumableArray((0, _styleConsole.default)('yellow', '')));\n    });\n    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToEnd\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');\n    var options = {\n      behavior: behavior || 'smooth'\n    };\n    mode === MODE_TOP ? scrollToTop(options) : scrollToBottom(options);\n  }, [debug, mode, scrollToBottom, scrollToTop]);\n  var scrollToStart = (0, _react.useCallback)(function () {\n    var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        behavior = _ref7.behavior;\n\n    debug(function () {\n      return ['%cscrollToStart%c: Called'].concat(_toConsumableArray((0, _styleConsole.default)('yellow', '')));\n    });\n    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToStart\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');\n    var options = {\n      behavior: behavior || 'smooth'\n    };\n    mode === MODE_TOP ? scrollToBottom(options) : scrollToTop(options);\n  }, [debug, mode, scrollToBottom, scrollToTop]);\n  var scrollToSticky = (0, _react.useCallback)(function () {\n    if (target) {\n      if (initialScrollBehaviorRef.current === 'auto') {\n        debug(function () {\n          return [\"%ctarget changed%c: Initial scroll\"].concat(_toConsumableArray((0, _styleConsole.default)('blue')));\n        });\n        target.scrollTop = mode === MODE_TOP ? 0 : target.scrollHeight - target.offsetHeight;\n        initialScrollBehaviorRef.current = false;\n        return;\n      } // This is very similar to scrollToEnd().\n      // Instead of scrolling to end, it will call props.scroller() to determines how far it should scroll.\n      // This function could be called while it is auto-scrolling.\n\n\n      var animateFrom = animateFromRef.current;\n      var offsetHeight = target.offsetHeight,\n          scrollHeight = target.scrollHeight,\n          scrollTop = target.scrollTop;\n      var maxValue = mode === MODE_TOP ? 0 : Math.max(0, scrollHeight - offsetHeight - scrollTop);\n      var minValue = Math.max(0, animateFrom - scrollTop);\n      var rawNextValue = scroller({\n        maxValue: maxValue,\n        minValue: minValue,\n        offsetHeight: offsetHeight,\n        scrollHeight: scrollHeight,\n        scrollTop: scrollTop\n      });\n      var nextValue = Math.max(0, Math.min(maxValue, rawNextValue));\n      var nextAnimateTo;\n\n      if (mode === MODE_TOP || nextValue !== maxValue) {\n        nextAnimateTo = scrollTop + nextValue;\n      } else {\n        // When scrolling to bottom, we should scroll to \"100%\".\n        // Otherwise, if we scroll to any number, it will lose stickiness when elements are adding too fast.\n        // \"100%\" is a special argument intended to make sure stickiness is not lost while new elements are being added.\n        nextAnimateTo = '100%';\n      }\n\n      debug(function () {\n        return [[\"%cscrollToSticky%c: Will animate from %c\".concat(animateFrom, \"px%c to %c\").concat(typeof nextAnimateTo === 'number' ? nextAnimateTo + 'px' : nextAnimateTo.replace(/%/g, '%%'), \"%c (%c\").concat((nextAnimateTo === '100%' ? maxValue : nextAnimateTo) + animateFrom, \"px%c)\")].concat(_toConsumableArray((0, _styleConsole.default)('orange')), _toConsumableArray((0, _styleConsole.default)('purple')), _toConsumableArray((0, _styleConsole.default)('purple')), _toConsumableArray((0, _styleConsole.default)('purple'))), {\n          animateFrom: animateFrom,\n          maxValue: maxValue,\n          minValue: minValue,\n          nextAnimateTo: nextAnimateTo,\n          nextValue: nextValue,\n          offsetHeight: offsetHeight,\n          rawNextValue: rawNextValue,\n          scrollHeight: scrollHeight,\n          scrollTop: scrollTop\n        }];\n      });\n      scrollTo(nextAnimateTo, {\n        behavior: 'smooth'\n      });\n    }\n  }, [animateFromRef, debug, mode, scroller, scrollTo, target]);\n  var handleScroll = (0, _react.useCallback)(function (_ref8) {\n    var timeStampLow = _ref8.timeStampLow; // Currently, there are no reliable way to check if the \"scroll\" event is trigger due to\n    // user gesture, programmatic scrolling, or Chrome-synthesized \"scroll\" event to compensate size change.\n    // Thus, we use our best-effort to guess if it is triggered by user gesture, and disable sticky if it is heading towards the start direction.\n\n    if (timeStampLow <= ignoreScrollEventBeforeRef.current || !target) {\n      // Since we debounce \"scroll\" event, this handler might be called after spineTo.onEnd (a.k.a. artificial scrolling).\n      // We should ignore debounced event fired after scrollEnd, because without skipping them, the userInitiatedScroll calculated below will not be accurate.\n      // Thus, on a fast machine, adding elements super fast will lose the \"stickiness\".\n      return;\n    }\n\n    var _computeViewState = computeViewState({\n      mode: mode,\n      target: target\n    }),\n        atBottom = _computeViewState.atBottom,\n        atEnd = _computeViewState.atEnd,\n        atStart = _computeViewState.atStart,\n        atTop = _computeViewState.atTop;\n\n    setAtBottom(atBottom);\n    setAtEnd(atEnd);\n    setAtStart(atStart);\n    setAtTop(atTop); // Chrome will emit \"synthetic\" scroll event if the container is resized or an element is added\n    // We need to ignore these \"synthetic\" events\n    // Repro: In playground, press 4-1-5-1-1 (small, add one, normal, add one, add one)\n    //        Nomatter how fast or slow the sequence is being pressed, it should still stick to the bottom\n\n    var nextOffsetHeight = target.offsetHeight,\n        nextScrollHeight = target.scrollHeight;\n    var offsetHeight = offsetHeightRef.current;\n    var scrollHeight = scrollHeightRef.current;\n    var offsetHeightChanged = nextOffsetHeight !== offsetHeight;\n    var scrollHeightChanged = nextScrollHeight !== scrollHeight;\n\n    if (offsetHeightChanged) {\n      offsetHeightRef.current = nextOffsetHeight;\n    }\n\n    if (scrollHeightChanged) {\n      scrollHeightRef.current = nextScrollHeight;\n    } // Sticky means:\n    // - If it is scrolled programatically, we are still in sticky mode\n    // - If it is scrolled by the user, then sticky means if we are at the end\n    // Only update stickiness if the scroll event is not due to synthetic scroll done by Chrome\n\n\n    if (!offsetHeightChanged && !scrollHeightChanged) {\n      // We are sticky if we are animating to the end, or we are already at the end.\n      // We can be \"animating but not sticky\" by calling \"scrollTo(100)\" where the container scrollHeight is 200px.\n      var nextSticky = animating && isEnd(animateTo, mode) || atEnd;\n\n      if (sticky !== nextSticky) {\n        debug(function () {\n          return [[\"%conScroll%c: %csetSticky%c(%c\".concat(nextSticky, \"%c)\")].concat(_toConsumableArray((0, _styleConsole.default)('red')), _toConsumableArray((0, _styleConsole.default)('red')), _toConsumableArray((0, _styleConsole.default)('purple'))), [\"(animating = %c\".concat(animating, \"%c && isEnd = %c\").concat(isEnd(animateTo, mode), \"%c) || atEnd = %c\").concat(atEnd, \"%c\")].concat(_toConsumableArray((0, _styleConsole.default)('purple')), _toConsumableArray((0, _styleConsole.default)('purple')), _toConsumableArray((0, _styleConsole.default)('purple')), [{\n            animating: animating,\n            animateTo: animateTo,\n            atEnd: atEnd,\n            mode: mode,\n            offsetHeight: target.offsetHeight,\n            scrollHeight: target.scrollHeight,\n            sticky: sticky,\n            nextSticky: nextSticky\n          }])];\n        });\n        setSticky(nextSticky);\n      }\n    } else if (sticky) {\n      debug(function () {\n        return [[\"%conScroll%c: Size changed while sticky, calling %cscrollToSticky()%c\"].concat(_toConsumableArray((0, _styleConsole.default)('red')), _toConsumableArray((0, _styleConsole.default)('orange')), [{\n          offsetHeightChanged: offsetHeightChanged,\n          scrollHeightChanged: scrollHeightChanged\n        }]), {\n          nextOffsetHeight: nextOffsetHeight,\n          prevOffsetHeight: offsetHeight,\n          nextScrollHeight: nextScrollHeight,\n          prevScrollHeight: scrollHeight\n        }];\n      });\n      scrollToSticky();\n    }\n\n    var actualScrollTop = target.scrollTop;\n    scrollPositionObserversRef.current.forEach(function (observer) {\n      return observer({\n        scrollTop: actualScrollTop\n      });\n    });\n  }, [animateTo, animating, debug, ignoreScrollEventBeforeRef, mode, offsetHeightRef, scrollHeightRef, scrollPositionObserversRef, scrollToSticky, setAtBottom, setAtEnd, setAtStart, setAtTop, setSticky, sticky, target]);\n  (0, _react.useEffect)(function () {\n    if (target) {\n      var stickyButNotAtEndSince = false;\n      var timeout = setImmediateInterval(function () {\n        if (sticky) {\n          if (!computeViewState({\n            mode: mode,\n            target: target\n          }).atEnd) {\n            if (!stickyButNotAtEndSince) {\n              stickyButNotAtEndSince = Date.now();\n            } else if (Date.now() - stickyButNotAtEndSince > SCROLL_DECISION_DURATION) {\n              // Quirks: In Firefox, after user scroll down, Firefox do two things:\n              //         1. Set to a new \"scrollTop\"\n              //         2. Fire \"scroll\" event\n              //         For what we observed, #1 is fired about 20ms before #2. There is a chance that this stickyCheckTimeout is being scheduled between 1 and 2.\n              //         That means, if we just look at #1 to decide if we should scroll, we will always scroll, in oppose to the user's intention.\n              // Repro: Open Firefox, set checkInterval to a lower number, and try to scroll by dragging the scroll handler. It will jump back.\n              // The \"animating\" check will make sure stickiness is not lost when elements are adding at a very fast pace.\n              if (!animating) {\n                animateFromRef.current = target.scrollTop;\n                debug(function () {\n                  return [\"%cInterval check%c: Should sticky but not at end, calling %cscrollToSticky()%c to scroll\"].concat(_toConsumableArray((0, _styleConsole.default)('navy')), _toConsumableArray((0, _styleConsole.default)('orange')));\n                });\n                scrollToSticky();\n              }\n\n              stickyButNotAtEndSince = false;\n            }\n          } else {\n            stickyButNotAtEndSince = false;\n          }\n        } else if (target.scrollHeight <= target.offsetHeight && !sticky) {\n          // When the container is emptied, we will set sticky back to true.\n          setSticky(true);\n        }\n      }, Math.max(MIN_CHECK_INTERVAL, checkInterval) || MIN_CHECK_INTERVAL);\n      return function () {\n        return clearInterval(timeout);\n      };\n    }\n  }, [animating, checkInterval, debug, mode, scrollToSticky, setSticky, sticky, target]);\n  var styleToClassName = (0, _react.useMemo)(function () {\n    var emotion = emotionPool[nonce] || (emotionPool[nonce] = (0, _createEmotion.default)({\n      key: 'react-scroll-to-bottom--css-' + (0, _createCSSKey.default)(),\n      nonce: nonce\n    }));\n    return function (style) {\n      return emotion.css(style) + '';\n    };\n  }, [nonce]);\n  var internalContext = (0, _react.useMemo)(function () {\n    return {\n      observeScrollPosition: observeScrollPosition,\n      setTarget: setTarget,\n      styleToClassName: styleToClassName\n    };\n  }, [observeScrollPosition, setTarget, styleToClassName]);\n  var state1Context = (0, _react.useMemo)(function () {\n    return {\n      atBottom: atBottom,\n      atEnd: atEnd,\n      atStart: atStart,\n      atTop: atTop,\n      mode: mode\n    };\n  }, [atBottom, atEnd, atStart, atTop, mode]);\n  var state2Context = (0, _react.useMemo)(function () {\n    return {\n      animating: animating,\n      animatingToEnd: animating && isEnd(animateTo, mode),\n      sticky: sticky\n    };\n  }, [animating, animateTo, debug, mode, sticky]);\n  var combinedStateContext = (0, _react.useMemo)(function () {\n    return _objectSpread(_objectSpread({}, state1Context), state2Context);\n  }, [state1Context, state2Context]);\n  var functionContext = (0, _react.useMemo)(function () {\n    return {\n      scrollTo: scrollTo,\n      scrollToBottom: scrollToBottom,\n      scrollToEnd: scrollToEnd,\n      scrollToStart: scrollToStart,\n      scrollToTop: scrollToTop\n    };\n  }, [scrollTo, scrollToBottom, scrollToEnd, scrollToStart, scrollToTop]);\n  (0, _react.useEffect)(function () {\n    // We need to update the \"scrollHeight\" value to latest when the user do a focus inside the box.\n    //\n    // This is because:\n    // - In our code that mitigate Chrome synthetic scrolling, that code will look at whether \"scrollHeight\" value is latest or not.\n    // - That code only run on \"scroll\" event.\n    // - That means, on every \"scroll\" event, if the \"scrollHeight\" value is not latest, we will skip modifying the stickiness.\n    // - That means, if the user \"focus\" to an element that cause the scroll view to scroll to the bottom, the user agent will fire \"scroll\" event.\n    //   Since the \"scrollHeight\" is not latest value, this \"scroll\" event will be ignored and stickiness will not be modified.\n    // - That means, if the user \"focus\" to a newly added element that is at the end of the scroll view, the \"scroll to bottom\" button will continue to show.\n    //\n    // Repro in Chrome:\n    // 1. Fill up a scroll view\n    // 2. Scroll up, the \"scroll to bottom\" button should show up\n    // 3. Click \"Add a button\"\n    // 4. Click on the scroll view (to pseudo-focus on it)\n    // 5. Press TAB, the scroll view will be at the bottom\n    //\n    // Expect:\n    // - The \"scroll to bottom\" button should be gone.\n    if (target) {\n      var handleFocus = function handleFocus() {\n        scrollHeightRef.current = target.scrollHeight;\n      };\n\n      target.addEventListener('focus', handleFocus, {\n        capture: true,\n        passive: true\n      });\n      return function () {\n        return target.removeEventListener('focus', handleFocus);\n      };\n    }\n  }, [target]);\n  debug(function () {\n    return [[\"%cRender%c: Render\"].concat(_toConsumableArray((0, _styleConsole.default)('cyan', ''))), {\n      animateTo: animateTo,\n      animating: animating,\n      sticky: sticky,\n      target: target\n    }];\n  });\n  return /*#__PURE__*/_react.default.createElement(_InternalContext.default.Provider, {\n    value: internalContext\n  }, /*#__PURE__*/_react.default.createElement(_FunctionContext.default.Provider, {\n    value: functionContext\n  }, /*#__PURE__*/_react.default.createElement(_StateContext.default.Provider, {\n    value: combinedStateContext\n  }, /*#__PURE__*/_react.default.createElement(_State1Context.default.Provider, {\n    value: state1Context\n  }, /*#__PURE__*/_react.default.createElement(_State2Context.default.Provider, {\n    value: state2Context\n  }, children, target && /*#__PURE__*/_react.default.createElement(_EventSpy.default, {\n    debounce: debounce,\n    name: \"scroll\",\n    onEvent: handleScroll,\n    target: target\n  }), target && animateTo !== null && /*#__PURE__*/_react.default.createElement(_SpineTo.default, {\n    name: \"scrollTop\",\n    onEnd: handleSpineToEnd,\n    target: target,\n    value: animateTo\n  }))))));\n};\n\nComposer.defaultProps = {\n  checkInterval: 100,\n  children: undefined,\n  debounce: 17,\n  debug: false,\n  initialScrollBehavior: 'smooth',\n  mode: undefined,\n  nonce: undefined,\n  scroller: DEFAULT_SCROLLER\n};\nComposer.propTypes = {\n  checkInterval: _propTypes.default.number,\n  children: _propTypes.default.any,\n  debounce: _propTypes.default.number,\n  debug: _propTypes.default.bool,\n  initialScrollBehavior: _propTypes.default.oneOf(['auto', 'smooth']),\n  mode: _propTypes.default.oneOf(['bottom', 'top']),\n  nonce: _propTypes.default.string,\n  scroller: _propTypes.default.func\n};\nvar _default = Composer;\nexports.default = _default;","map":{"version":3,"sources":["../../src/ScrollToBottom/Composer.js"],"names":["DEFAULT_SCROLLER","MIN_CHECK_INTERVAL","MODE_BOTTOM","MODE_TOP","NEAR_END_THRESHOLD","SCROLL_DECISION_DURATION","emotionPool","fn","setInterval","mode","target","offsetHeight","scrollHeight","scrollTop","atBottom","atTop","atEnd","atStart","animateTo","Composer","checkInterval","children","debounce","debug","forceDebug","initialScrollBehavior","nonce","scroller","force","ignoreScrollEventBeforeRef","initialScrollBehaviorRef","setAnimateTo","setTarget","animateFromRef","offsetHeightRef","scrollHeightRef","animating","setAtBottom","setAtEnd","setAtTop","setAtStart","sticky","setSticky","scrollPositionObserversRef","observeScrollPosition","scrollPositionObservers","index","handleSpineToEnd","Date","isEnd","scrollTo","behavior","nextAnimateTo","console","scrollToBottom","scrollToTop","scrollToEnd","options","scrollToStart","scrollToSticky","animateFrom","maxValue","Math","minValue","rawNextValue","nextValue","handleScroll","timeStampLow","computeViewState","nextOffsetHeight","nextScrollHeight","offsetHeightChanged","scrollHeightChanged","nextSticky","prevOffsetHeight","prevScrollHeight","actualScrollTop","observer","stickyButNotAtEndSince","timeout","setImmediateInterval","clearInterval","styleToClassName","emotion","key","internalContext","state1Context","state2Context","animatingToEnd","combinedStateContext","functionContext","handleFocus","capture","passive","PropTypes","func"],"mappings":"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","sourcesContent":["import createEmotion from 'create-emotion';\nimport PropTypes from 'prop-types';\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\n\nimport createCSSKey from '../createCSSKey';\nimport createDebug from '../utils/debug';\nimport EventSpy from '../EventSpy';\nimport FunctionContext from './FunctionContext';\nimport InternalContext from './InternalContext';\nimport SpineTo from '../SpineTo';\nimport State1Context from './State1Context';\nimport State2Context from './State2Context';\nimport StateContext from './StateContext';\nimport styleConsole from '../utils/styleConsole';\n\nconst DEFAULT_SCROLLER = () => Infinity;\nconst MIN_CHECK_INTERVAL = 17; // 1 frame\nconst MODE_BOTTOM = 'bottom';\nconst MODE_TOP = 'top';\nconst NEAR_END_THRESHOLD = 1;\nconst SCROLL_DECISION_DURATION = 34; // 2 frames\n\n// We pool the emotion object by nonce.\n// This is to make sure we don't generate too many unneeded <style> tags.\nconst emotionPool = {};\n\nfunction setImmediateInterval(fn, ms) {\n  fn();\n\n  return setInterval(fn, ms);\n}\n\nfunction computeViewState({ mode, target: { offsetHeight, scrollHeight, scrollTop } }) {\n  const atBottom = scrollHeight - scrollTop - offsetHeight < NEAR_END_THRESHOLD;\n  const atTop = scrollTop < NEAR_END_THRESHOLD;\n\n  const atEnd = mode === MODE_TOP ? atTop : atBottom;\n  const atStart = mode !== MODE_TOP ? atTop : atBottom;\n\n  return {\n    atBottom,\n    atEnd,\n    atStart,\n    atTop\n  };\n}\n\nfunction isEnd(animateTo, mode) {\n  return animateTo === (mode === MODE_TOP ? 0 : '100%');\n}\n\nconst Composer = ({\n  checkInterval,\n  children,\n  debounce,\n  debug: forceDebug,\n  initialScrollBehavior,\n  mode,\n  nonce,\n  scroller\n}) => {\n  const debug = useMemo(() => createDebug(`<ScrollToBottom>`, { force: forceDebug }), [forceDebug]);\n\n  mode = mode === MODE_TOP ? MODE_TOP : MODE_BOTTOM;\n\n  const ignoreScrollEventBeforeRef = useRef(0);\n  const initialScrollBehaviorRef = useRef(initialScrollBehavior);\n  const [animateTo, setAnimateTo] = useState(mode === MODE_TOP ? 0 : '100%');\n  const [target, setTarget] = useState(null);\n\n  // Internal context\n  const animateFromRef = useRef(0);\n  const offsetHeightRef = useRef(0);\n  const scrollHeightRef = useRef(0);\n\n  // State context\n  const animating = animateTo !== null;\n  const [atBottom, setAtBottom] = useState(true);\n  const [atEnd, setAtEnd] = useState(true);\n  const [atTop, setAtTop] = useState(true);\n  const [atStart, setAtStart] = useState(false);\n  const [sticky, setSticky] = useState(true);\n\n  // High-rate state context\n  const scrollPositionObserversRef = useRef([]);\n  const observeScrollPosition = useCallback(\n    fn => {\n      scrollPositionObserversRef.current.push(fn);\n      target && fn({ scrollTop: target.scrollTop });\n\n      return () => {\n        const { current: scrollPositionObservers } = scrollPositionObserversRef;\n        const index = scrollPositionObservers.indexOf(fn);\n\n        ~index && scrollPositionObservers.splice(index, 1);\n      };\n    },\n    [scrollPositionObserversRef, target]\n  );\n\n  const handleSpineToEnd = useCallback(() => {\n    debug(() => [\n      '%cSpineTo%c: %conEnd%c is fired.',\n      ...styleConsole('magenta'),\n      ...styleConsole('orange'),\n      { animateTo }\n    ]);\n\n    ignoreScrollEventBeforeRef.current = Date.now();\n\n    // handleScrollEnd may end at a position which should lose stickiness.\n    // In that case, we will need to set sticky to false to stop the interval check.\n    // Test case:\n    // 1. Add a scroller that always return 0\n    // 2. Show a panel with mode === MODE_BOTTOM\n    // 3. Programmatically scroll to 0 (set element.scrollTop = 0)\n    // Expected: it should not repetitively call scrollTo(0)\n    //           it should set stickiness to false\n\n    isEnd(animateTo, mode) || setSticky(false);\n    setAnimateTo(null);\n  }, [animateTo, debug, ignoreScrollEventBeforeRef, mode, setAnimateTo, setSticky]);\n\n  // Function context\n  const scrollTo = useCallback(\n    (nextAnimateTo, { behavior } = {}) => {\n      if (typeof nextAnimateTo !== 'number' && nextAnimateTo !== '100%') {\n        return console.warn('react-scroll-to-bottom: Arguments passed to scrollTo() must be either number or \"100%\".');\n      }\n\n      // If it is trying to scroll to a position which is not \"atEnd\", it should set sticky to false after scroll ended.\n\n      debug(() => [\n        [\n          `%cscrollTo%c: Will scroll to %c${\n            typeof nextAnimateTo === 'number' ? nextAnimateTo + 'px' : nextAnimateTo.replace(/%/gu, '%%')\n          }%c`,\n          ...styleConsole('lime', ''),\n          ...styleConsole('purple')\n        ],\n        {\n          behavior,\n          nextAnimateTo,\n          target\n        }\n      ]);\n\n      if (behavior === 'auto') {\n        // Stop any existing animation\n        handleSpineToEnd();\n\n        if (target) {\n          // Jump to the scroll position\n          target.scrollTop = nextAnimateTo === '100%' ? target.scrollHeight - target.offsetHeight : nextAnimateTo;\n        }\n      } else {\n        behavior !== 'smooth' &&\n          console.warn(\n            'react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollTo\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'\n          );\n\n        setAnimateTo(nextAnimateTo);\n      }\n\n      // This is for handling a case. When calling scrollTo('100%', { behavior: 'auto' }) multiple times, it would lose stickiness.\n      isEnd(nextAnimateTo, mode) && setSticky(true);\n    },\n    [debug, handleSpineToEnd, mode, setAnimateTo, setSticky, target]\n  );\n\n  const scrollToBottom = useCallback(\n    ({ behavior } = {}) => {\n      debug(() => ['%cscrollToBottom%c: Called', ...styleConsole('yellow', '')]);\n\n      behavior !== 'smooth' &&\n        console.warn(\n          'react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToBottom\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'\n        );\n\n      scrollTo('100%', { behavior: behavior || 'smooth' });\n    },\n    [debug, scrollTo]\n  );\n\n  const scrollToTop = useCallback(\n    ({ behavior } = {}) => {\n      debug(() => ['%cscrollToTop%c: Called', ...styleConsole('yellow', '')]);\n\n      behavior !== 'smooth' &&\n        console.warn(\n          'react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToTop\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'\n        );\n\n      scrollTo(0, { behavior: behavior || 'smooth' });\n    },\n    [debug, scrollTo]\n  );\n\n  const scrollToEnd = useCallback(\n    ({ behavior } = {}) => {\n      debug(() => ['%cscrollToEnd%c: Called', ...styleConsole('yellow', '')]);\n\n      behavior !== 'smooth' &&\n        console.warn(\n          'react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToEnd\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'\n        );\n\n      const options = { behavior: behavior || 'smooth' };\n\n      mode === MODE_TOP ? scrollToTop(options) : scrollToBottom(options);\n    },\n    [debug, mode, scrollToBottom, scrollToTop]\n  );\n\n  const scrollToStart = useCallback(\n    ({ behavior } = {}) => {\n      debug(() => ['%cscrollToStart%c: Called', ...styleConsole('yellow', '')]);\n\n      behavior !== 'smooth' &&\n        console.warn(\n          'react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToStart\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'\n        );\n\n      const options = { behavior: behavior || 'smooth' };\n\n      mode === MODE_TOP ? scrollToBottom(options) : scrollToTop(options);\n    },\n    [debug, mode, scrollToBottom, scrollToTop]\n  );\n\n  const scrollToSticky = useCallback(() => {\n    if (target) {\n      if (initialScrollBehaviorRef.current === 'auto') {\n        debug(() => [`%ctarget changed%c: Initial scroll`, ...styleConsole('blue')]);\n\n        target.scrollTop = mode === MODE_TOP ? 0 : target.scrollHeight - target.offsetHeight;\n        initialScrollBehaviorRef.current = false;\n\n        return;\n      }\n\n      // This is very similar to scrollToEnd().\n      // Instead of scrolling to end, it will call props.scroller() to determines how far it should scroll.\n      // This function could be called while it is auto-scrolling.\n\n      const { current: animateFrom } = animateFromRef;\n      const { offsetHeight, scrollHeight, scrollTop } = target;\n\n      const maxValue = mode === MODE_TOP ? 0 : Math.max(0, scrollHeight - offsetHeight - scrollTop);\n      const minValue = Math.max(0, animateFrom - scrollTop);\n\n      const rawNextValue = scroller({ maxValue, minValue, offsetHeight, scrollHeight, scrollTop });\n\n      const nextValue = Math.max(0, Math.min(maxValue, rawNextValue));\n\n      let nextAnimateTo;\n\n      if (mode === MODE_TOP || nextValue !== maxValue) {\n        nextAnimateTo = scrollTop + nextValue;\n      } else {\n        // When scrolling to bottom, we should scroll to \"100%\".\n        // Otherwise, if we scroll to any number, it will lose stickiness when elements are adding too fast.\n        // \"100%\" is a special argument intended to make sure stickiness is not lost while new elements are being added.\n        nextAnimateTo = '100%';\n      }\n\n      debug(() => [\n        [\n          `%cscrollToSticky%c: Will animate from %c${animateFrom}px%c to %c${\n            typeof nextAnimateTo === 'number' ? nextAnimateTo + 'px' : nextAnimateTo.replace(/%/gu, '%%')\n          }%c (%c${(nextAnimateTo === '100%' ? maxValue : nextAnimateTo) + animateFrom}px%c)`,\n          ...styleConsole('orange'),\n          ...styleConsole('purple'),\n          ...styleConsole('purple'),\n          ...styleConsole('purple')\n        ],\n        {\n          animateFrom,\n          maxValue,\n          minValue,\n          nextAnimateTo,\n          nextValue,\n          offsetHeight,\n          rawNextValue,\n          scrollHeight,\n          scrollTop\n        }\n      ]);\n\n      scrollTo(nextAnimateTo, { behavior: 'smooth' });\n    }\n  }, [animateFromRef, debug, mode, scroller, scrollTo, target]);\n\n  const handleScroll = useCallback(\n    ({ timeStampLow }) => {\n      // Currently, there are no reliable way to check if the \"scroll\" event is trigger due to\n      // user gesture, programmatic scrolling, or Chrome-synthesized \"scroll\" event to compensate size change.\n      // Thus, we use our best-effort to guess if it is triggered by user gesture, and disable sticky if it is heading towards the start direction.\n\n      if (timeStampLow <= ignoreScrollEventBeforeRef.current || !target) {\n        // Since we debounce \"scroll\" event, this handler might be called after spineTo.onEnd (a.k.a. artificial scrolling).\n        // We should ignore debounced event fired after scrollEnd, because without skipping them, the userInitiatedScroll calculated below will not be accurate.\n        // Thus, on a fast machine, adding elements super fast will lose the \"stickiness\".\n\n        return;\n      }\n\n      const { atBottom, atEnd, atStart, atTop } = computeViewState({ mode, target });\n\n      setAtBottom(atBottom);\n      setAtEnd(atEnd);\n      setAtStart(atStart);\n      setAtTop(atTop);\n\n      // Chrome will emit \"synthetic\" scroll event if the container is resized or an element is added\n      // We need to ignore these \"synthetic\" events\n      // Repro: In playground, press 4-1-5-1-1 (small, add one, normal, add one, add one)\n      //        Nomatter how fast or slow the sequence is being pressed, it should still stick to the bottom\n      const { offsetHeight: nextOffsetHeight, scrollHeight: nextScrollHeight } = target;\n      const { current: offsetHeight } = offsetHeightRef;\n      const { current: scrollHeight } = scrollHeightRef;\n      const offsetHeightChanged = nextOffsetHeight !== offsetHeight;\n      const scrollHeightChanged = nextScrollHeight !== scrollHeight;\n\n      if (offsetHeightChanged) {\n        offsetHeightRef.current = nextOffsetHeight;\n      }\n\n      if (scrollHeightChanged) {\n        scrollHeightRef.current = nextScrollHeight;\n      }\n\n      // Sticky means:\n      // - If it is scrolled programatically, we are still in sticky mode\n      // - If it is scrolled by the user, then sticky means if we are at the end\n\n      // Only update stickiness if the scroll event is not due to synthetic scroll done by Chrome\n      if (!offsetHeightChanged && !scrollHeightChanged) {\n        // We are sticky if we are animating to the end, or we are already at the end.\n        // We can be \"animating but not sticky\" by calling \"scrollTo(100)\" where the container scrollHeight is 200px.\n        const nextSticky = (animating && isEnd(animateTo, mode)) || atEnd;\n\n        if (sticky !== nextSticky) {\n          debug(() => [\n            [\n              `%conScroll%c: %csetSticky%c(%c${nextSticky}%c)`,\n              ...styleConsole('red'),\n              ...styleConsole('red'),\n              ...styleConsole('purple')\n            ],\n            [\n              `(animating = %c${animating}%c && isEnd = %c${isEnd(animateTo, mode)}%c) || atEnd = %c${atEnd}%c`,\n              ...styleConsole('purple'),\n              ...styleConsole('purple'),\n              ...styleConsole('purple'),\n              {\n                animating,\n                animateTo,\n                atEnd,\n                mode,\n                offsetHeight: target.offsetHeight,\n                scrollHeight: target.scrollHeight,\n                sticky,\n                nextSticky\n              }\n            ]\n          ]);\n\n          setSticky(nextSticky);\n        }\n      } else if (sticky) {\n        debug(() => [\n          [\n            `%conScroll%c: Size changed while sticky, calling %cscrollToSticky()%c`,\n            ...styleConsole('red'),\n            ...styleConsole('orange'),\n            {\n              offsetHeightChanged,\n              scrollHeightChanged\n            }\n          ],\n          {\n            nextOffsetHeight,\n            prevOffsetHeight: offsetHeight,\n            nextScrollHeight,\n            prevScrollHeight: scrollHeight\n          }\n        ]);\n\n        scrollToSticky();\n      }\n\n      const { scrollTop: actualScrollTop } = target;\n\n      scrollPositionObserversRef.current.forEach(observer => observer({ scrollTop: actualScrollTop }));\n    },\n    [\n      animateTo,\n      animating,\n      debug,\n      ignoreScrollEventBeforeRef,\n      mode,\n      offsetHeightRef,\n      scrollHeightRef,\n      scrollPositionObserversRef,\n      scrollToSticky,\n      setAtBottom,\n      setAtEnd,\n      setAtStart,\n      setAtTop,\n      setSticky,\n      sticky,\n      target\n    ]\n  );\n\n  useEffect(() => {\n    if (target) {\n      let stickyButNotAtEndSince = false;\n\n      const timeout = setImmediateInterval(() => {\n        if (sticky) {\n          if (!computeViewState({ mode, target }).atEnd) {\n            if (!stickyButNotAtEndSince) {\n              stickyButNotAtEndSince = Date.now();\n            } else if (Date.now() - stickyButNotAtEndSince > SCROLL_DECISION_DURATION) {\n              // Quirks: In Firefox, after user scroll down, Firefox do two things:\n              //         1. Set to a new \"scrollTop\"\n              //         2. Fire \"scroll\" event\n              //         For what we observed, #1 is fired about 20ms before #2. There is a chance that this stickyCheckTimeout is being scheduled between 1 and 2.\n              //         That means, if we just look at #1 to decide if we should scroll, we will always scroll, in oppose to the user's intention.\n              // Repro: Open Firefox, set checkInterval to a lower number, and try to scroll by dragging the scroll handler. It will jump back.\n\n              // The \"animating\" check will make sure stickiness is not lost when elements are adding at a very fast pace.\n              if (!animating) {\n                animateFromRef.current = target.scrollTop;\n\n                debug(() => [\n                  `%cInterval check%c: Should sticky but not at end, calling %cscrollToSticky()%c to scroll`,\n                  ...styleConsole('navy'),\n                  ...styleConsole('orange')\n                ]);\n\n                scrollToSticky();\n              }\n\n              stickyButNotAtEndSince = false;\n            }\n          } else {\n            stickyButNotAtEndSince = false;\n          }\n        } else if (target.scrollHeight <= target.offsetHeight && !sticky) {\n          // When the container is emptied, we will set sticky back to true.\n\n          setSticky(true);\n        }\n      }, Math.max(MIN_CHECK_INTERVAL, checkInterval) || MIN_CHECK_INTERVAL);\n\n      return () => clearInterval(timeout);\n    }\n  }, [animating, checkInterval, debug, mode, scrollToSticky, setSticky, sticky, target]);\n\n  const styleToClassName = useMemo(() => {\n    const emotion =\n      emotionPool[nonce] ||\n      (emotionPool[nonce] = createEmotion({ key: 'react-scroll-to-bottom--css-' + createCSSKey(), nonce }));\n\n    return style => emotion.css(style) + '';\n  }, [nonce]);\n\n  const internalContext = useMemo(\n    () => ({\n      observeScrollPosition,\n      setTarget,\n      styleToClassName\n    }),\n    [observeScrollPosition, setTarget, styleToClassName]\n  );\n\n  const state1Context = useMemo(\n    () => ({\n      atBottom,\n      atEnd,\n      atStart,\n      atTop,\n      mode\n    }),\n    [atBottom, atEnd, atStart, atTop, mode]\n  );\n\n  const state2Context = useMemo(\n    () => ({\n      animating,\n      animatingToEnd: animating && isEnd(animateTo, mode),\n      sticky\n    }),\n    [animating, animateTo, debug, mode, sticky]\n  );\n\n  const combinedStateContext = useMemo(\n    () => ({\n      ...state1Context,\n      ...state2Context\n    }),\n    [state1Context, state2Context]\n  );\n\n  const functionContext = useMemo(\n    () => ({\n      scrollTo,\n      scrollToBottom,\n      scrollToEnd,\n      scrollToStart,\n      scrollToTop\n    }),\n    [scrollTo, scrollToBottom, scrollToEnd, scrollToStart, scrollToTop]\n  );\n\n  useEffect(() => {\n    // We need to update the \"scrollHeight\" value to latest when the user do a focus inside the box.\n    //\n    // This is because:\n    // - In our code that mitigate Chrome synthetic scrolling, that code will look at whether \"scrollHeight\" value is latest or not.\n    // - That code only run on \"scroll\" event.\n    // - That means, on every \"scroll\" event, if the \"scrollHeight\" value is not latest, we will skip modifying the stickiness.\n    // - That means, if the user \"focus\" to an element that cause the scroll view to scroll to the bottom, the user agent will fire \"scroll\" event.\n    //   Since the \"scrollHeight\" is not latest value, this \"scroll\" event will be ignored and stickiness will not be modified.\n    // - That means, if the user \"focus\" to a newly added element that is at the end of the scroll view, the \"scroll to bottom\" button will continue to show.\n    //\n    // Repro in Chrome:\n    // 1. Fill up a scroll view\n    // 2. Scroll up, the \"scroll to bottom\" button should show up\n    // 3. Click \"Add a button\"\n    // 4. Click on the scroll view (to pseudo-focus on it)\n    // 5. Press TAB, the scroll view will be at the bottom\n    //\n    // Expect:\n    // - The \"scroll to bottom\" button should be gone.\n    if (target) {\n      const handleFocus = () => {\n        scrollHeightRef.current = target.scrollHeight;\n      };\n\n      target.addEventListener('focus', handleFocus, { capture: true, passive: true });\n\n      return () => target.removeEventListener('focus', handleFocus);\n    }\n  }, [target]);\n\n  debug(() => [\n    [`%cRender%c: Render`, ...styleConsole('cyan', '')],\n    {\n      animateTo,\n      animating,\n      sticky,\n      target\n    }\n  ]);\n\n  return (\n    <InternalContext.Provider value={internalContext}>\n      <FunctionContext.Provider value={functionContext}>\n        <StateContext.Provider value={combinedStateContext}>\n          <State1Context.Provider value={state1Context}>\n            <State2Context.Provider value={state2Context}>\n              {children}\n              {target && <EventSpy debounce={debounce} name=\"scroll\" onEvent={handleScroll} target={target} />}\n              {target && animateTo !== null && (\n                <SpineTo name=\"scrollTop\" onEnd={handleSpineToEnd} target={target} value={animateTo} />\n              )}\n            </State2Context.Provider>\n          </State1Context.Provider>\n        </StateContext.Provider>\n      </FunctionContext.Provider>\n    </InternalContext.Provider>\n  );\n};\n\nComposer.defaultProps = {\n  checkInterval: 100,\n  children: undefined,\n  debounce: 17,\n  debug: false,\n  initialScrollBehavior: 'smooth',\n  mode: undefined,\n  nonce: undefined,\n  scroller: DEFAULT_SCROLLER\n};\n\nComposer.propTypes = {\n  checkInterval: PropTypes.number,\n  children: PropTypes.any,\n  debounce: PropTypes.number,\n  debug: PropTypes.bool,\n  initialScrollBehavior: PropTypes.oneOf(['auto', 'smooth']),\n  mode: PropTypes.oneOf(['bottom', 'top']),\n  nonce: PropTypes.string,\n  scroller: PropTypes.func\n};\n\nexport default Composer;\n"]},"metadata":{},"sourceType":"script"}